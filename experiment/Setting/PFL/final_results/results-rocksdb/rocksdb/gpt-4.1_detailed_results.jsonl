{"instance_index": 5, "error_index": 1, "error_result": {"is_successful": false, "is_exact_match": false, "is_valid": false, "error_line": "./include/rocksdb/data_structure.h:589:28: error: no matching function for call to 'lower_bound(std::vector<rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator> >::iterator, std::vector<rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator> >::iterator, const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&, rocksdb::IntervalSet<rocksdb::Slice, rocksdb::Comparator>::findPosition(const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&)::<lambda(const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&, const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&)>)'", "patches": [{"error_line": "./include/rocksdb/data_structure.h:589:28: error: no matching function for call to 'lower_bound(std::vector<rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator> >::iterator, std::vector<rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator> >::iterator, const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&, rocksdb::IntervalSet<rocksdb::Slice, rocksdb::Comparator>::findPosition(const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&)::<lambda(const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&, const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&)>)'", "file_path": "./include/rocksdb/data_structure.h", "start_line": 589, "end_line": 594, "original_code": "    return std::lower_bound(\n        intervals_.begin(), intervals_.end(), interval,\n        [this](const Interval<Slice, Comparator>& a, \n               const Interval<Slice, Comparator>& b) {\n          return comp_->Compare(a.start(), b.start()) < 0;\n        });", "fixed_code": "    return std::lower_bound(\n        intervals_.begin(), intervals_.end(), interval,\n        [this](const Interval<Slice, Comparator>& a, \n               const Interval<Slice, Comparator>& b) {\n          return comp_->Compare(a.start(), b.start()) < 0;\n        });", "confidence": 0.5, "explanation": ""}, {"error_line": "./include/rocksdb/data_structure.h:589:28: error: no matching function for call to 'lower_bound(std::vector<rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator> >::iterator, std::vector<rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator> >::iterator, const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&, rocksdb::IntervalSet<rocksdb::Slice, rocksdb::Comparator>::findPosition(const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&)::<lambda(const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&, const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&)>)'", "file_path": "./include/rocksdb/data_structure.h", "start_line": 589, "end_line": 594, "original_code": "    return std::lower_bound(\n        intervals_.begin(), intervals_.end(), interval,\n        [this](const Interval<Slice, Comparator>& a, \n               const Interval<Slice, Comparator>& b) {\n          return comp_->Compare(a.start(), b.start()) < 0;\n        });", "fixed_code": "    return std::lower_bound(\n        intervals_.begin(), intervals_.end(), interval,\n        [this](const Interval<Slice, Comparator>& a, const Interval<Slice, Comparator>& b) -> bool {\n          return comp_->Compare(a.start(), b.start()) < 0;\n        });", "confidence": 0.5, "explanation": ""}], "errors_before": ["./include/rocksdb/data_structure.h:589:28: error: no matching function for call to 'lower_bound(std::vector<rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator> >::iterator, std::vector<rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator> >::iterator, const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&, rocksdb::IntervalSet<rocksdb::Slice, rocksdb::Comparator>::findPosition(const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&)::<lambda(const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&, const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&)>)'"], "errors_after": ["./include/rocksdb/data_structure.h:589:32: error: no matching function for call to 'lower_bound(std::vector<rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator> >::iterator, std::vector<rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator> >::iterator, const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&, rocksdb::IntervalSet<rocksdb::Slice, rocksdb::Comparator>::findPosition(const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&)::<lambda(const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&, const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&)>)'"], "error_detail": "In file included from ./include/rocksdb/cache.h:20,\n./include/rocksdb/data_structure.h: In member function 'std::vector<rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator> >::iterator rocksdb::IntervalSet<rocksdb::Slice, rocksdb::Comparator>::findPosition(const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&)':\n./include/rocksdb/data_structure.h:589:28: error: no matching function for call to 'lower_bound(std::vector<rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator> >::iterator, std::vector<rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator> >::iterator, const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&, rocksdb::IntervalSet<rocksdb::Slice, rocksdb::Comparator>::findPosition(const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&)::<lambda(const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&, const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&)>)'\n  589 |     return std::lower_bound(\n      |            ~~~~~~~~~~~~~~~~^\n  590 |         intervals_.begin(), intervals_.end(), interval,\n      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  591 |         [this](const Interval<Slice, Comparator>& a,\n      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  592 |                const Interval<Slice, Comparator>& b) {\n      |                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  593 |           return comp_->Compare(a.start(), b.start()) < 0;\n      |           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  594 |         });\n      |         ~~", "time": 9.74313759803772, "evaluation_mode": "full"}, "timestamp": "2025-08-20 15:14:38"}
{"instance_index": 4, "error_index": 1, "error_result": {"is_successful": false, "is_exact_match": false, "is_valid": false, "error_line": "./include/rocksdb/data_structure.h:600:28: error: no matching function for call to 'lower_bound(std::vector<rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator> >::iterator, std::vector<rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator> >::iterator, const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&, rocksdb::IntervalSet<rocksdb::Slice, rocksdb::Comparator>::findPosition(const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&)::<lambda(const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&, const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&)>)'", "patches": [{"error_line": "./include/rocksdb/data_structure.h:600:28: error: no matching function for call to 'lower_bound(std::vector<rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator> >::iterator, std::vector<rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator> >::iterator, const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&, rocksdb::IntervalSet<rocksdb::Slice, rocksdb::Comparator>::findPosition(const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&)::<lambda(const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&, const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&)>)'", "file_path": "./include/rocksdb/data_structure.h", "start_line": 600, "end_line": 605, "original_code": "    return std::lower_bound(\n        intervals_.begin(), intervals_.end(), interval,\n        [this](const Interval<Slice, Comparator>& a, \n               const Interval<Slice, Comparator>& b) {\n          return comp_->Compare(a.start(), b.start()) < 0;\n        });", "fixed_code": "    return std::lower_bound(\n        intervals_.begin(), intervals_.end(), interval,\n        [this](const Interval<Slice, Comparator>& a, \n               const Interval<Slice, Comparator>& b) {\n          return comp_->Compare(a.start(), b.start()) < 0;\n        }); // Note: std::lower_bound expects a predicate of (element, value)", "confidence": 0.5, "explanation": ""}], "errors_before": ["./include/rocksdb/data_structure.h:600:28: error: no matching function for call to 'lower_bound(std::vector<rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator> >::iterator, std::vector<rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator> >::iterator, const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&, rocksdb::IntervalSet<rocksdb::Slice, rocksdb::Comparator>::findPosition(const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&)::<lambda(const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&, const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&)>)'"], "errors_after": ["./include/rocksdb/data_structure.h:600:28: error: no matching function for call to 'lower_bound(std::vector<rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator> >::iterator, std::vector<rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator> >::iterator, const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&, rocksdb::IntervalSet<rocksdb::Slice, rocksdb::Comparator>::findPosition(const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&)::<lambda(const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&, const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&)>)'"], "error_detail": "In file included from ./include/rocksdb/cache.h:20,\n./include/rocksdb/data_structure.h: In member function 'std::vector<rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator> >::iterator rocksdb::IntervalSet<rocksdb::Slice, rocksdb::Comparator>::findPosition(const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&)':\n./include/rocksdb/data_structure.h:600:28: error: no matching function for call to 'lower_bound(std::vector<rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator> >::iterator, std::vector<rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator> >::iterator, const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&, rocksdb::IntervalSet<rocksdb::Slice, rocksdb::Comparator>::findPosition(const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&)::<lambda(const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&, const rocksdb::Interval<rocksdb::Slice, rocksdb::Comparator>&)>)'\n  600 |     return std::lower_bound(\n      |            ~~~~~~~~~~~~~~~~^\n  601 |         intervals_.begin(), intervals_.end(), interval,\n      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  602 |         [this](const Interval<Slice, Comparator>& a,\n      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  603 |                const Interval<Slice, Comparator>& b) {\n      |                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  604 |           return comp_->Compare(a.start(), b.start()) < 0;\n      |           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  605 |         });\n      |         ~~", "time": 8.188554048538208, "evaluation_mode": "full"}, "timestamp": "2025-08-20 15:14:54"}
{"instance_index": 1, "error_index": 1, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "./table/block_based/flush_block_policy_impl.h:12:7: error: redefinition of 'class rocksdb::FlushBlockEveryKeyPolicy'", "patches": [{"error_line": "./table/block_based/flush_block_policy_impl.h:12:7: error: redefinition of 'class rocksdb::FlushBlockEveryKeyPolicy'", "file_path": "./table/block_based/flush_block_policy_impl.h", "start_line": 12, "end_line": 24, "original_code": "class FlushBlockEveryKeyPolicy : public FlushBlockPolicy {\n public:\n  bool Update(const Slice& /*key*/, const Slice& /*value*/) override {\n    if (!start_) {\n      start_ = true;\n      return false;\n    }\n    return true;\n  }\n\n private:\n  bool start_ = false;\n};", "fixed_code": "#ifndef ROCKSDB_FLUSH_BLOCK_EVERY_KEY_POLICY_DEFINED\n#define ROCKSDB_FLUSH_BLOCK_EVERY_KEY_POLICY_DEFINED\nclass FlushBlockEveryKeyPolicy : public FlushBlockPolicy {\n public:\n  bool Update(const Slice& /*key*/, const Slice& /*value*/) override {\n    if (!start_) {\n      start_ = true;\n      return false;\n    }\n    return true;\n  }\n\n private:\n  bool start_ = false;\n};\n#endif", "confidence": 0.5, "explanation": ""}], "errors_before": ["./table/block_based/flush_block_policy_impl.h:12:7: error: redefinition of 'class rocksdb::FlushBlockEveryKeyPolicy'", "./table/block_based/flush_block_policy_impl.h:26:7: error: redefinition of 'class rocksdb::FlushBlockEveryKeyPolicyFactory'", "./table/block_based/flush_block_policy_impl.h:42:7: error: redefinition of 'class rocksdb::RetargetableFlushBlockPolicy'"], "errors_after": ["./table/block_based/flush_block_policy_impl.h:29:7: error: redefinition of 'class rocksdb::FlushBlockEveryKeyPolicyFactory'", "./table/block_based/flush_block_policy_impl.h:45:7: error: redefinition of 'class rocksdb::RetargetableFlushBlockPolicy'"], "error_detail": "In file included from table/block_based/flush_block_policy.cc:16,\n./table/block_based/flush_block_policy_impl.h:12:7: error: redefinition of 'class rocksdb::FlushBlockEveryKeyPolicy'\n   12 | class FlushBlockEveryKeyPolicy : public FlushBlockPolicy {\n      |       ^~~~~~~~~~~~~~~~~~~~~~~~", "time": 7.183422327041626, "evaluation_mode": "full"}, "timestamp": "2025-08-20 15:15:30"}
{"instance_index": 1, "error_index": 2, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "./table/block_based/flush_block_policy_impl.h:26:7: error: redefinition of 'class rocksdb::FlushBlockEveryKeyPolicyFactory'", "patches": [{"error_line": "./table/block_based/flush_block_policy_impl.h:26:7: error: redefinition of 'class rocksdb::FlushBlockEveryKeyPolicyFactory'", "file_path": "./table/block_based/flush_block_policy_impl.h", "start_line": 29, "end_line": 41, "original_code": "class FlushBlockEveryKeyPolicyFactory : public FlushBlockPolicyFactory {\n public:\n  explicit FlushBlockEveryKeyPolicyFactory() {}\n\n  static const char* kClassName() { return \"FlushBlockEveryKeyPolicyFactory\"; }\n  const char* Name() const override { return kClassName(); }\n\n  FlushBlockPolicy* NewFlushBlockPolicy(\n      const BlockBasedTableOptions& /*table_options*/,\n      const BlockBuilder& /*data_block_builder*/) const override {\n    return new FlushBlockEveryKeyPolicy;\n  }\n};", "fixed_code": "#ifndef ROCKSDB_FLUSH_BLOCK_EVERY_KEY_POLICY_FACTORY_DEFINED\n#define ROCKSDB_FLUSH_BLOCK_EVERY_KEY_POLICY_FACTORY_DEFINED\nclass FlushBlockEveryKeyPolicyFactory : public FlushBlockPolicyFactory {\n public:\n  explicit FlushBlockEveryKeyPolicyFactory() {}\n\n  static const char* kClassName() { return \"FlushBlockEveryKeyPolicyFactory\"; }\n  const char* Name() const override { return kClassName(); }\n\n  FlushBlockPolicy* NewFlushBlockPolicy(\n      const BlockBasedTableOptions& /*table_options*/,\n      const BlockBuilder& /*data_block_builder*/) const override {\n    return new FlushBlockEveryKeyPolicy;\n  }\n};\n#endif", "confidence": 0.5, "explanation": ""}], "errors_before": ["./table/block_based/flush_block_policy_impl.h:12:7: error: redefinition of 'class rocksdb::FlushBlockEveryKeyPolicy'", "./table/block_based/flush_block_policy_impl.h:26:7: error: redefinition of 'class rocksdb::FlushBlockEveryKeyPolicyFactory'", "./table/block_based/flush_block_policy_impl.h:42:7: error: redefinition of 'class rocksdb::RetargetableFlushBlockPolicy'"], "errors_after": ["./table/block_based/flush_block_policy_impl.h:12:7: error: redefinition of 'class rocksdb::FlushBlockEveryKeyPolicy'", "./table/block_based/flush_block_policy_impl.h:45:7: error: redefinition of 'class rocksdb::RetargetableFlushBlockPolicy'"], "error_detail": "In file included from table/block_based/index_builder.h:21,\n./table/block_based/flush_block_policy_impl.h:12:7: note: previous definition of 'class rocksdb::FlushBlockEveryKeyPolicy'\n./table/block_based/flush_block_policy_impl.h:26:7: error: redefinition of 'class rocksdb::FlushBlockEveryKeyPolicyFactory'\n   26 | class FlushBlockEveryKeyPolicyFactory : public FlushBlockPolicyFactory {\n      |       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", "time": 5.4142796993255615, "evaluation_mode": "full"}, "timestamp": "2025-08-20 15:19:26"}
{"instance_index": 1, "error_index": 3, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "./table/block_based/flush_block_policy_impl.h:42:7: error: redefinition of 'class rocksdb::RetargetableFlushBlockPolicy'", "patches": [{"error_line": "./table/block_based/flush_block_policy_impl.h:42:7: error: redefinition of 'class rocksdb::RetargetableFlushBlockPolicy'", "file_path": "./table/block_based/flush_block_policy_impl.h", "start_line": 42, "end_line": 56, "original_code": "class RetargetableFlushBlockPolicy : public FlushBlockPolicy {\n public:\n  RetargetableFlushBlockPolicy(const BlockBuilder& data_block_builder)\n      : data_block_builder_(&data_block_builder) {}\n\n  void Retarget(const BlockBuilder& data_block_builder) {\n    data_block_builder_ = &data_block_builder;\n  }\n\n protected:\n  const BlockBuilder* data_block_builder_;\n};", "fixed_code": "#ifndef ROCKSDB_RETARGETABLE_FLUSH_BLOCK_POLICY_DEFINED\n#define ROCKSDB_RETARGETABLE_FLUSH_BLOCK_POLICY_DEFINED\nclass RetargetableFlushBlockPolicy : public FlushBlockPolicy {\n public:\n  RetargetableFlushBlockPolicy(const BlockBuilder& data_block_builder)\n      : data_block_builder_(&data_block_builder) {}\n\n  void Retarget(const BlockBuilder& data_block_builder) {\n    data_block_builder_ = &data_block_builder;\n  }\n\n protected:\n  const BlockBuilder* data_block_builder_;\n};\n#endif", "confidence": 0.5, "explanation": ""}], "errors_before": ["./table/block_based/flush_block_policy_impl.h:12:7: error: redefinition of 'class rocksdb::FlushBlockEveryKeyPolicy'", "./table/block_based/flush_block_policy_impl.h:26:7: error: redefinition of 'class rocksdb::FlushBlockEveryKeyPolicyFactory'", "./table/block_based/flush_block_policy_impl.h:42:7: error: redefinition of 'class rocksdb::RetargetableFlushBlockPolicy'"], "errors_after": ["./table/block_based/flush_block_policy_impl.h:12:7: error: redefinition of 'class rocksdb::FlushBlockEveryKeyPolicy'", "./table/block_based/flush_block_policy_impl.h:26:7: error: redefinition of 'class rocksdb::FlushBlockEveryKeyPolicyFactory'"], "error_detail": "./table/block_based/flush_block_policy_impl.h:26:7: note: previous definition of 'class rocksdb::FlushBlockEveryKeyPolicyFactory'\n./table/block_based/flush_block_policy_impl.h:42:7: error: redefinition of 'class rocksdb::RetargetableFlushBlockPolicy'\n   42 | class RetargetableFlushBlockPolicy : public FlushBlockPolicy {\n      |       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~", "time": 4.950936555862427, "evaluation_mode": "full"}, "timestamp": "2025-08-20 15:23:29"}
{"instance_index": 6, "error_index": 1, "error_result": {"is_successful": false, "is_exact_match": false, "is_valid": false, "error_line": "util/auto_tune_compressor.cc:385:17: error: 'offpeak_time_' was not declared in this scope", "patches": [{"error_line": "util/auto_tune_compressor.cc:385:17: error: 'offpeak_time_' was not declared in this scope", "file_path": "include/rocksdb/advanced_compression.h", "start_line": 42, "end_line": 59, "original_code": "struct DynamicBudget : public Budget, public EventListener {\n  explicit DynamicBudget(double max_rate, double min_rate,\n                         double stall_max_rate, double stall_min_rate)\n      : Budget(max_rate, min_rate),\n        stall_max_rate_(stall_max_rate),\n        stall_min_rate_(stall_min_rate),\n        stall_condition_(WriteStallCondition::kNormal){};\n  double GetMaxRate() override;\n  double GetMinRate() override;\n  void OnStallConditionsChanged(const WriteStallInfo& info) override {\n    stall_condition_ = info.condition.cur;\n  };\n\n private:\n  double stall_max_rate_;\n  double stall_min_rate_;\n  WriteStallCondition stall_condition_;\n};", "fixed_code": "struct DynamicBudget : public Budget, public EventListener {\n  explicit DynamicBudget(double max_rate, double min_rate,\n                         double stall_max_rate, double stall_min_rate)\n      : Budget(max_rate, min_rate),\n        stall_max_rate_(stall_max_rate),\n        stall_min_rate_(stall_min_rate),\n        stall_condition_(WriteStallCondition::kNormal){};\n  double GetMaxRate() override;\n  double GetMinRate() override;\n  void OnStallConditionsChanged(const WriteStallInfo& info) override {\n    stall_condition_ = info.condition.cur;\n  };\n\n private:\n  double stall_max_rate_;\n  double stall_min_rate_;\n  WriteStallCondition stall_condition_;\n  OffPeakTime offpeak_time_;\n};", "confidence": 0.5, "explanation": ""}], "errors_before": ["util/auto_tune_compressor.cc:385:17: error: 'offpeak_time_' was not declared in this scope", "util/auto_tune_compressor.cc:398:17: error: 'offpeak_time_' was not declared in this scope"], "errors_after": ["./include/rocksdb/advanced_compression.h:59:3: error: 'OffPeakTime' does not name a type; did you mean 'OffpeakTimeInfo'?"], "error_detail": "util/auto_tune_compressor.cc:385:17: error: 'offpeak_time_' was not declared in this scope\n  385 |     auto info = offpeak_time_.GetOffpeakTimeInfo(now);\n      |                 ^~~~~~~~~~~~~\nutil/auto_tune_compressor.cc: In member function 'virtual double rocksdb::DynamicBudget::GetMinRate()':", "time": 12.249792098999023, "evaluation_mode": "full"}, "timestamp": "2025-08-20 15:29:03"}
{"instance_index": 7, "error_index": 1, "error_result": {"is_successful": false, "is_exact_match": false, "is_valid": false, "error_line": "util/auto_tune_compressor.cc:385:17: error: use of undeclared identifier 'offpeak_time_'", "patches": [{"error_line": "util/auto_tune_compressor.cc:385:17: error: use of undeclared identifier 'offpeak_time_'", "file_path": "include/rocksdb/advanced_compression.h", "start_line": 42, "end_line": 59, "original_code": "struct DynamicBudget : public Budget, public EventListener {\n  explicit DynamicBudget(double max_rate, double min_rate,\n                         double stall_max_rate, double stall_min_rate)\n      : Budget(max_rate, min_rate),\n        stall_max_rate_(stall_max_rate),\n        stall_min_rate_(stall_min_rate),\n        stall_condition_(WriteStallCondition::kNormal){};\n  double GetMaxRate() override;\n  double GetMinRate() override;\n  void OnStallConditionsChanged(const WriteStallInfo& info) override {\n    stall_condition_ = info.condition.cur;\n  };\n\n private:\n  double stall_max_rate_;\n  double stall_min_rate_;\n  WriteStallCondition stall_condition_;\n};", "fixed_code": "struct DynamicBudget : public Budget, public EventListener {\n  explicit DynamicBudget(double max_rate, double min_rate,\n                         double stall_max_rate, double stall_min_rate)\n      : Budget(max_rate, min_rate),\n        stall_max_rate_(stall_max_rate),\n        stall_min_rate_(stall_min_rate),\n        stall_condition_(WriteStallCondition::kNormal){};\n  double GetMaxRate() override;\n  double GetMinRate() override;\n  void OnStallConditionsChanged(const WriteStallInfo& info) override {\n    stall_condition_ = info.condition.cur;\n  };\n\n private:\n  double stall_max_rate_;\n  double stall_min_rate_;\n  WriteStallCondition stall_condition_;\n  OffPeakTime offpeak_time_;\n};", "confidence": 0.5, "explanation": ""}], "errors_before": ["util/auto_tune_compressor.cc:385:17: error: use of undeclared identifier 'offpeak_time_'", "util/auto_tune_compressor.cc:398:17: error: use of undeclared identifier 'offpeak_time_'"], "errors_after": ["./include/rocksdb/advanced_compression.h:59:3: error: unknown type name 'OffPeakTime'"], "error_detail": "util/auto_tune_compressor.cc:385:17: error: use of undeclared identifier 'offpeak_time_'\n    auto info = offpeak_time_.GetOffpeakTimeInfo(now);\n                ^", "time": 8.46083950996399, "evaluation_mode": "full"}, "timestamp": "2025-08-20 15:32:01"}
{"instance_index": 2, "error_index": 1, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "/__w/rocksdb/rocksdb/cache/compressed_secondary_cache.cc:269:21: error: 'total_size' was not declared in this scope", "patches": [{"error_line": "/__w/rocksdb/rocksdb/cache/compressed_secondary_cache.cc:269:21: error: 'total_size' was not declared in this scope", "file_path": "/__w/rocksdb/rocksdb/cache/compressed_secondary_cache.cc", "start_line": 267, "end_line": 270, "original_code": "#ifdef ROCKSDB_MALLOC_USABLE_SIZE\n    size_t charge = malloc_usable_size(allocation.get());\n#else\n    size_t charge = total_size;\n#endif", "fixed_code": "#ifdef ROCKSDB_MALLOC_USABLE_SIZE\n    size_t charge = malloc_usable_size(allocation.get());\n#else\n    size_t charge = header_size + (enable_split_merge ? 0 : tagged_data.size());\n#endif", "confidence": 0.5, "explanation": ""}], "errors_before": ["/tmp/rocksdb_repo_temp_2_s14mu52g/cache/compressed_secondary_cache.cc:269:21: error: 'total_size' was not declared in this scope"], "errors_after": [], "error_detail": "/__w/rocksdb/rocksdb/cache/compressed_secondary_cache.cc: In member function 'rocksdb::Status rocksdb::CompressedSecondaryCache::InsertInternal(const rocksdb::Slice&, rocksdb::Cache::ObjectPtr, const rocksdb::Cache::CacheItemHelper*, rocksdb::CompressionType, rocksdb::CacheTier)':\n/__w/rocksdb/rocksdb/cache/compressed_secondary_cache.cc:269:21: error: 'total_size' was not declared in this scope\n  269 |     size_t charge = total_size;\n      |                     ^~~~~~~~~~", "time": 14.533086061477661, "evaluation_mode": "full"}, "timestamp": "2025-08-20 15:36:15"}
{"instance_index": 10, "error_index": 1, "error_result": {"is_successful": false, "is_exact_match": false, "is_valid": false, "error_line": "./util/rate_tracker.h:27:20: error: redefinition of 'constexpr const uint64_t rocksdb::kMicrosInSecond'", "patches": [{"error_line": "./util/rate_tracker.h:27:20: error: redefinition of 'constexpr const uint64_t rocksdb::kMicrosInSecond'", "file_path": "./util/rate_tracker.h", "start_line": 27, "end_line": 27, "original_code": "constexpr uint64_t kMicrosInSecond = 1000000;", "fixed_code": "#ifndef ROCKSDB_KMICROSINSECOND_DEFINED\n#define ROCKSDB_KMICROSINSECOND_DEFINED\nconstexpr uint64_t kMicrosInSecond = 1000000;\n#endif", "confidence": 0.5, "explanation": ""}], "errors_before": ["./util/rate_tracker.h:27:20: error: redefinition of 'constexpr const uint64_t rocksdb::kMicrosInSecond'"], "errors_after": ["./util/rate_tracker.h:29:20: error: redefinition of 'constexpr const uint64_t rocksdb::kMicrosInSecond'"], "error_detail": "In file included from ./util/auto_tune_compressor.h:17,\n./util/rate_tracker.h:27:20: error: redefinition of 'constexpr const uint64_t rocksdb::kMicrosInSecond'\n   27 | constexpr uint64_t kMicrosInSecond = 1000000;\n      |                    ^~~~~~~~~~~~~~~", "time": 5.094348192214966, "evaluation_mode": "full"}, "timestamp": "2025-08-20 15:36:53"}
{"instance_index": 8, "error_index": 1, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "tools/db_bench_tool.cc:1295:44: error: cannot initialize a variable of type 'void (*)(int) __attribute__((noreturn))' with an rvalue of type 'void (*)(int)'", "patches": [{"error_line": "tools/db_bench_tool.cc:1295:44: error: cannot initialize a variable of type 'void (*)(int) __attribute__((noreturn))' with an rvalue of type 'void (*)(int)'", "file_path": "tools/db_bench_tool.cc", "start_line": 1294, "end_line": 1295, "original_code": "[[noreturn]] void db_bench_exit(int status) { exit(status); };\nusing ExitFuncType = void (*)(int status);", "fixed_code": "void db_bench_exit(int status) __attribute__((noreturn));\nvoid db_bench_exit(int status) { exit(status); }\nusing ExitFuncType = void (*)(int status);", "confidence": 0.5, "explanation": ""}, {"error_line": "tools/db_bench_tool.cc:1295:44: error: cannot initialize a variable of type 'void (*)(int) __attribute__((noreturn))' with an rvalue of type 'void (*)(int)'", "file_path": "tools/db_bench_tool.cc", "start_line": 1296, "end_line": 1296, "original_code": "__attribute__((__noreturn__)) ExitFuncType exitFunc_ = &db_bench_exit;", "fixed_code": "ExitFuncType exitFunc_ = &db_bench_exit;", "confidence": 0.5, "explanation": ""}], "errors_before": ["tools/db_bench_tool.cc:1295:44: error: cannot initialize a variable of type 'void (*)(int) __attribute__((noreturn))' with an rvalue of type 'void (*)(int)'", "tools/db_bench_tool.cc:8727:15: error: incompatible function pointer types assigning to 'void (*)(int) __attribute__((noreturn))' from 'void (*)(int)'"], "errors_after": [], "error_detail": "tools/db_bench_tool.cc:1295:44: error: cannot initialize a variable of type 'void (*)(int) __attribute__((noreturn))' with an rvalue of type 'void (*)(int)'\n__attribute__((__noreturn__)) ExitFuncType exitFunc_ = &db_bench_exit;\n                                           ^           ~~~~~~~~~~~~~~", "time": 10.421301364898682, "evaluation_mode": "full"}, "timestamp": "2025-08-20 15:52:52"}
{"instance_index": 9, "error_index": 1, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "tools/db_bench_tool.cc:1295:44: error: cannot initialize a variable of type 'void (*)(int) __attribute__((noreturn))' with an rvalue of type 'void (*)(int)'", "patches": [{"error_line": "tools/db_bench_tool.cc:1295:44: error: cannot initialize a variable of type 'void (*)(int) __attribute__((noreturn))' with an rvalue of type 'void (*)(int)'", "file_path": "tools/db_bench_tool.cc", "start_line": 1295, "end_line": 1295, "original_code": "__attribute__((__noreturn__)) ExitFuncType exitFunc_ = &db_bench_exit;", "fixed_code": "ExitFuncType exitFunc_ = &db_bench_exit;", "confidence": 0.5, "explanation": ""}], "errors_before": ["tools/db_bench_tool.cc:1295:44: error: cannot initialize a variable of type 'void (*)(int) __attribute__((noreturn))' with an rvalue of type 'void (*)(int)'"], "errors_after": [], "error_detail": "tools/db_bench_tool.cc:1295:44: error: cannot initialize a variable of type 'void (*)(int) __attribute__((noreturn))' with an rvalue of type 'void (*)(int)'\n__attribute__((__noreturn__)) ExitFuncType exitFunc_ = &db_bench_exit;\n                                           ^           ~~~~~~~~~~~~~~\nmkdir -p db_stress_tool && clang++  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Wshift-sign-overflow -Wambiguous-reversed-operator -Wimplicit-fallthrough -Wreinterpret-base-class -Wundefined-reinterpret-cast -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -Wshorten-64-to-32 -DHAVE_UINT128_EXTENSION  -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c db_stress_tool/db_stress_gflags.cc -o db_stress_tool/db_stress_gflags.o\nmkdir -p db_stress_tool && clang++  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Wshift-sign-overflow -Wambiguous-reversed-operator -Wimplicit-fallthrough -Wreinterpret-base-class -Wundefined-reinterpret-cast -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -Wshorten-64-to-32 -DHAVE_UINT128_EXTENSION  -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c db_stress_tool/db_stress_listener.cc -o db_stress_tool/db_stress_listener.o\nmkdir -p db_stress_tool && clang++  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Wshift-sign-overflow -Wambiguous-reversed-operator -Wimplicit-fallthrough -Wreinterpret-base-class -Wundefined-reinterpret-cast -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -Wshorten-64-to-32 -DHAVE_UINT128_EXTENSION  -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c db_stress_tool/db_stress_shared_state.cc -o db_stress_tool/db_stress_shared_state.o\nmkdir -p db_stress_tool && clang++  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Wshift-sign-overflow -Wambiguous-reversed-operator -Wimplicit-fallthrough -Wreinterpret-base-class -Wundefined-reinterpret-cast -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -Wshorten-64-to-32 -DHAVE_UINT128_EXTENSION  -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c db_stress_tool/db_stress_stat.cc -o db_stress_tool/db_stress_stat.o\nmkdir -p db_stress_tool && clang++  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Wshift-sign-overflow -Wambiguous-reversed-operator -Wimplicit-fallthrough -Wreinterpret-base-class -Wundefined-reinterpret-cast -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -Wshorten-64-to-32 -DHAVE_UINT128_EXTENSION  -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c db_stress_tool/db_stress_test_base.cc -o db_stress_tool/db_stress_test_base.o\nmkdir -p db_stress_tool && clang++  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Wshift-sign-overflow -Wambiguous-reversed-operator -Wimplicit-fallthrough -Wreinterpret-base-class -Wundefined-reinterpret-cast -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -Wshorten-64-to-32 -DHAVE_UINT128_EXTENSION  -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c db_stress_tool/db_stress_tool.cc -o db_stress_tool/db_stress_tool.o\nmkdir -p db_stress_tool && clang++  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Wshift-sign-overflow -Wambiguous-reversed-operator -Wimplicit-fallthrough -Wreinterpret-base-class -Wundefined-reinterpret-cast -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -Wshorten-64-to-32 -DHAVE_UINT128_EXTENSION  -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c db_stress_tool/db_stress_wide_merge_operator.cc -o db_stress_tool/db_stress_wide_merge_operator.o\nmkdir -p db_stress_tool && clang++  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Wshift-sign-overflow -Wambiguous-reversed-operator -Wimplicit-fallthrough -Wreinterpret-base-class -Wundefined-reinterpret-cast -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -Wshorten-64-to-32 -DHAVE_UINT128_EXTENSION  -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c db_stress_tool/expected_state.cc -o db_stress_tool/expected_state.o", "time": 8.252646684646606, "evaluation_mode": "full"}, "timestamp": "2025-08-20 15:57:22"}
{"instance_index": 15, "error_index": 1, "error_result": {"is_successful": false, "is_exact_match": false, "is_valid": false, "error_line": "/__w/rocksdb/rocksdb/util/auto_tune_compressor.cc:306:17: error: aggregate 'rocksdb::CostAwareCompressor::MeasureUtilization()::rusage usage' has incomplete type and cannot be defined", "patches": [{"error_line": "/__w/rocksdb/rocksdb/util/auto_tune_compressor.cc:306:17: error: aggregate 'rocksdb::CostAwareCompressor::MeasureUtilization()::rusage usage' has incomplete type and cannot be defined", "file_path": "/__w/rocksdb/rocksdb/util/auto_tune_compressor.cc", "start_line": 7, "end_line": 7, "original_code": "#include \"util/auto_tune_compressor.h\"", "fixed_code": "#include \"util/auto_tune_compressor.h\"\n#include <sys/resource.h>", "confidence": 0.5, "explanation": ""}], "errors_before": ["/tmp/rocksdb_repo_temp_15_uw70obju/util/auto_tune_compressor.cc:306:17: error: aggregate 'rocksdb::CostAwareCompressor::MeasureUtilization()::rusage usage' has incomplete type and cannot be defined", "/tmp/rocksdb_repo_temp_15_uw70obju/util/auto_tune_compressor.cc:307:13: error: 'RUSAGE_SELF' was not declared in this scope", "/tmp/rocksdb_repo_temp_15_uw70obju/util/auto_tune_compressor.cc:307:3: error: 'getrusage' was not declared in this scope; did you mean 'rusage'?"], "errors_after": ["/tmp/rocksdb_repo_temp_15_uw70obju/util/auto_tune_compressor.cc:8:10: fatal error: sys/resource.h: No such file or directory"], "error_detail": "/__w/rocksdb/rocksdb/include/rocksdb/data_structure.h: In instantiation of 'static constexpr rocksdb::SmallEnumSet<ENUM_TYPE, MAX_ENUMERATOR> rocksdb::SmallEnumSet<ENUM_TYPE, MAX_ENUMERATOR>::All() [with ENUM_TYPE = rocksdb::experimental::KeySegmentsExtractor::KeyCategory; ENUM_TYPE MAX_ENUMERATOR = rocksdb::experimental::KeySegmentsExtractor::kReservedHighCategory]':\n/__w/rocksdb/rocksdb/include/rocksdb/experimental.h:549:67:   required from here\n/usr/lib/gcc/x86_64-w64-mingw32/9.3-posix/include/c++/array:94:12: note: 'using StateT = struct std::array<long long unsigned int, 1>' {aka 'struct std::array<long long unsigned int, 1>'} has no user-provided default constructor\n/usr/lib/gcc/x86_64-w64-mingw32/9.3-posix/include/c++/array:110:56: note: and the implicitly-defined constructor does not initialize 'long long unsigned int std::array<long long unsigned int, 1>::_M_elems [1]'\n/__w/rocksdb/rocksdb/util/auto_tune_compressor.cc: In member function 'void rocksdb::CostAwareCompressor::MeasureUtilization()':\n/__w/rocksdb/rocksdb/util/auto_tune_compressor.cc:306:17: error: aggregate 'rocksdb::CostAwareCompressor::MeasureUtilization()::rusage usage' has incomplete type and cannot be defined\n  306 |   struct rusage usage;\n      |                 ^~~~~", "time": 7.861032009124756, "evaluation_mode": "full"}, "timestamp": "2025-08-20 16:05:42"}
{"instance_index": 13, "error_index": 1, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "./util/rate_tracker.h:27:27: error: redefinition of 'constexpr const uint64_t rocksdb::kMicrosInSecond'", "patches": [{"error_line": "./util/rate_tracker.h:27:27: error: redefinition of 'constexpr const uint64_t rocksdb::kMicrosInSecond'", "file_path": "./util/rate_tracker.h", "start_line": 27, "end_line": 27, "original_code": "static constexpr uint64_t kMicrosInSecond = 1000000;", "fixed_code": "", "confidence": 0.5, "explanation": ""}], "errors_before": ["./util/rate_tracker.h:27:27: error: redefinition of 'constexpr const uint64_t rocksdb::kMicrosInSecond'"], "errors_after": [], "error_detail": "In file included from ./util/auto_tune_compressor.h:17,\n./util/rate_tracker.h:27:27: error: redefinition of 'constexpr const uint64_t rocksdb::kMicrosInSecond'\n   27 | static constexpr uint64_t kMicrosInSecond = 1000000;\n      |                           ^~~~~~~~~~~~~~~", "time": 4.715466022491455, "evaluation_mode": "full"}, "timestamp": "2025-08-20 16:05:51"}
{"instance_index": 8, "error_index": 2, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "tools/db_bench_tool.cc:8727:15: error: incompatible function pointer types assigning to 'void (*)(int) __attribute__((noreturn))' from 'void (*)(int)'", "patches": [{"error_line": "tools/db_bench_tool.cc:8727:15: error: incompatible function pointer types assigning to 'void (*)(int) __attribute__((noreturn))' from 'void (*)(int)'", "file_path": "include/rocksdb/tool_hooks.h", "start_line": 72, "end_line": 72, "original_code": "  static void Exit(int status) { exit(status); }", "fixed_code": "  static void Exit(int status) __attribute__((noreturn)) { exit(status); }", "confidence": 0.5, "explanation": ""}], "errors_before": ["tools/db_bench_tool.cc:1295:44: error: cannot initialize a variable of type 'void (*)(int) __attribute__((noreturn))' with an rvalue of type 'void (*)(int)'", "tools/db_bench_tool.cc:8727:15: error: incompatible function pointer types assigning to 'void (*)(int) __attribute__((noreturn))' from 'void (*)(int)'"], "errors_after": ["tools/db_bench_tool.cc:1295:44: error: cannot initialize a variable of type 'void (*)(int) __attribute__((noreturn))' with an rvalue of type 'void (*)(int)'"], "error_detail": "tools/db_bench_tool.cc:8727:15: error: incompatible function pointer types assigning to 'void (*)(int) __attribute__((noreturn))' from 'void (*)(int)'\n  exitFunc_ = &hooks.Exit;\n              ^~~~~~~~~~~", "time": 8.441579341888428, "evaluation_mode": "full"}, "timestamp": "2025-08-20 16:14:37"}
{"instance_index": 14, "error_index": 1, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "/__w/rocksdb/rocksdb/util/auto_tune_compressor.cc:301:3: error: 'sysexit' was not declared in this scope", "patches": [{"error_line": "/__w/rocksdb/rocksdb/util/auto_tune_compressor.cc:301:3: error: 'sysexit' was not declared in this scope", "file_path": "util/auto_tune_compressor.cc", "start_line": 301, "end_line": 301, "original_code": "  sysexit(1);", "fixed_code": "  exit(1);", "confidence": 0.5, "explanation": ""}], "errors_before": ["/tmp/rocksdb_repo_temp_14_n4ch1s3t/util/auto_tune_compressor.cc:301:3: error: 'sysexit' was not declared in this scope"], "errors_after": [], "error_detail": "/__w/rocksdb/rocksdb/include/rocksdb/data_structure.h: In instantiation of 'static constexpr rocksdb::SmallEnumSet<ENUM_TYPE, MAX_ENUMERATOR> rocksdb::SmallEnumSet<ENUM_TYPE, MAX_ENUMERATOR>::All() [with ENUM_TYPE = rocksdb::experimental::KeySegmentsExtractor::KeyCategory; ENUM_TYPE MAX_ENUMERATOR = rocksdb::experimental::KeySegmentsExtractor::kReservedHighCategory]':\n/__w/rocksdb/rocksdb/include/rocksdb/experimental.h:549:67:   required from here\n/usr/lib/gcc/x86_64-w64-mingw32/9.3-posix/include/c++/array:94:12: note: 'using StateT = struct std::array<long long unsigned int, 1>' {aka 'struct std::array<long long unsigned int, 1>'} has no user-provided default constructor\n/usr/lib/gcc/x86_64-w64-mingw32/9.3-posix/include/c++/array:110:56: note: and the implicitly-defined constructor does not initialize 'long long unsigned int std::array<long long unsigned int, 1>::_M_elems [1]'\n/__w/rocksdb/rocksdb/util/auto_tune_compressor.cc: In member function 'void rocksdb::CostAwareCompressor::MeasureUtilization()':\n/__w/rocksdb/rocksdb/util/auto_tune_compressor.cc:301:3: error: 'sysexit' was not declared in this scope\n  301 |   sysexit(1);\n      |   ^~~~~~~", "time": 7.164199352264404, "evaluation_mode": "full"}, "timestamp": "2025-08-20 16:19:01"}
{"instance_index": 15, "error_index": 2, "error_result": {"is_successful": false, "is_exact_match": false, "is_valid": false, "error_line": "/__w/rocksdb/rocksdb/util/auto_tune_compressor.cc:307:13: error: 'RUSAGE_SELF' was not declared in this scope", "patches": [{"error_line": "/__w/rocksdb/rocksdb/util/auto_tune_compressor.cc:307:13: error: 'RUSAGE_SELF' was not declared in this scope", "file_path": "/__w/rocksdb/rocksdb/util/auto_tune_compressor.cc", "start_line": 7, "end_line": 7, "original_code": "#include \"util/auto_tune_compressor.h\"", "fixed_code": "#include \"util/auto_tune_compressor.h\"\n#include <sys/resource.h>", "confidence": 0.5, "explanation": ""}], "errors_before": ["/tmp/rocksdb_repo_temp_15_uw70obju/util/auto_tune_compressor.cc:306:17: error: aggregate 'rocksdb::CostAwareCompressor::MeasureUtilization()::rusage usage' has incomplete type and cannot be defined", "/tmp/rocksdb_repo_temp_15_uw70obju/util/auto_tune_compressor.cc:307:13: error: 'RUSAGE_SELF' was not declared in this scope", "/tmp/rocksdb_repo_temp_15_uw70obju/util/auto_tune_compressor.cc:307:3: error: 'getrusage' was not declared in this scope; did you mean 'rusage'?"], "errors_after": ["/tmp/rocksdb_repo_temp_15_uw70obju/util/auto_tune_compressor.cc:8:10: fatal error: sys/resource.h: No such file or directory"], "error_detail": "/__w/rocksdb/rocksdb/util/auto_tune_compressor.cc:307:13: error: 'RUSAGE_SELF' was not declared in this scope\n  307 |   getrusage(RUSAGE_SELF, &usage);\n      |             ^~~~~~~~~~~", "time": 6.859714031219482, "evaluation_mode": "full"}, "timestamp": "2025-08-20 16:20:39"}
{"instance_index": 15, "error_index": 3, "error_result": {"is_successful": false, "is_exact_match": false, "is_valid": false, "error_line": "/__w/rocksdb/rocksdb/util/auto_tune_compressor.cc:307:3: error: 'getrusage' was not declared in this scope; did you mean 'rusage''", "patches": [{"error_line": "/__w/rocksdb/rocksdb/util/auto_tune_compressor.cc:307:3: error: 'getrusage' was not declared in this scope; did you mean 'rusage''", "file_path": "/__w/rocksdb/rocksdb/util/auto_tune_compressor.cc", "start_line": 14, "end_line": 14, "original_code": "namespace ROCKSDB_NAMESPACE {", "fixed_code": "#include <sys/resource.h>\nnamespace ROCKSDB_NAMESPACE {", "confidence": 0.5, "explanation": ""}], "errors_before": ["/tmp/rocksdb_repo_temp_15_uw70obju/util/auto_tune_compressor.cc:306:17: error: aggregate 'rocksdb::CostAwareCompressor::MeasureUtilization()::rusage usage' has incomplete type and cannot be defined", "/tmp/rocksdb_repo_temp_15_uw70obju/util/auto_tune_compressor.cc:307:13: error: 'RUSAGE_SELF' was not declared in this scope", "/tmp/rocksdb_repo_temp_15_uw70obju/util/auto_tune_compressor.cc:307:3: error: 'getrusage' was not declared in this scope; did you mean 'rusage'?"], "errors_after": ["/tmp/rocksdb_repo_temp_15_uw70obju/util/auto_tune_compressor.cc:14:10: fatal error: sys/resource.h: No such file or directory"], "error_detail": "/__w/rocksdb/rocksdb/util/auto_tune_compressor.cc:307:3: error: 'getrusage' was not declared in this scope; did you mean 'rusage''\n  307 |   getrusage(RUSAGE_SELF, &usage);\n      |   ^~~~~~~~~\n      |   rusage", "time": 6.961443662643433, "evaluation_mode": "full"}, "timestamp": "2025-08-20 16:35:27"}
{"instance_index": 17, "error_index": 1, "error_result": {"is_successful": false, "is_exact_match": false, "is_valid": false, "error_line": "./util/cast_util.h:23:17: error: 'void' is not a class type", "patches": [{"error_line": "./util/cast_util.h:23:17: error: 'void' is not a class type", "file_path": "./util/cast_util.h", "start_line": 23, "end_line": 23, "original_code": "  assert(ret == dynamic_cast<DestClass*>(x));", "fixed_code": "  static_assert(!std::is_void<DestClass>::value && !std::is_void<SrcClass>::value, \"static_cast_with_check cannot be used with void type\");\n  assert(ret == dynamic_cast<DestClass*>(x));", "confidence": 0.5, "explanation": ""}], "errors_before": ["./util/cast_util.h:23:17: error: 'void' is not a class type"], "errors_after": ["./util/cast_util.h:24:17: error: 'void' is not a class type"], "error_detail": "In file included from utilities/transactions/lock/point/point_lock_manager.cc:6:\nIn file included from ./utilities/transactions/lock/point/point_lock_manager.h:20:\nIn file included from ./utilities/transactions/lock/lock_manager.h:12:\nIn file included from ./utilities/transactions/pessimistic_transaction.h:26:\nIn file included from ./utilities/transactions/transaction_base.h:12:\nIn file included from ./db/write_batch_internal.h:15:\nIn file included from ./db/kv_checksum.h:35:\nIn file included from ./db/dbformat.h:23:\nIn file included from ./util/coding.h:24:\n./util/cast_util.h:23:17: error: 'void' is not a class type\n  assert(ret == dynamic_cast<DestClass*>(x));\n                ^                        ~", "time": 7.16718864440918, "evaluation_mode": "full"}, "timestamp": "2025-08-20 16:36:06"}
{"instance_index": 16, "error_index": 1, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "./util/cast_util.h:23:17: error: cannot dynamic_cast 'x' (of type 'void*') to type 'struct rocksdb::KeyLockWaiter*' (source is not a pointer to class)", "patches": [{"error_line": "./util/cast_util.h:23:17: error: cannot dynamic_cast 'x' (of type 'void*') to type 'struct rocksdb::KeyLockWaiter*' (source is not a pointer to class)", "file_path": "./util/cast_util.h", "start_line": 23, "end_line": 23, "original_code": "  assert(ret == dynamic_cast<DestClass*>(x));", "fixed_code": "  if constexpr (!std::is_void<SrcClass>::value) {\n    assert(ret == dynamic_cast<DestClass*>(x));\n  }", "confidence": 0.5, "explanation": ""}], "errors_before": ["./util/cast_util.h:23:17: error: cannot dynamic_cast 'x' (of type 'void*') to type 'struct rocksdb::KeyLockWaiter*' (source is not a pointer to class)", "./util/cast_util.h:23:17: error: cannot dynamic_cast 'x' (of type 'void*') to type 'class std::unordered_map<unsigned int, std::shared_ptr<rocksdb::LockMap>, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<std::pair<const unsigned int, std::shared_ptr<rocksdb::LockMap> > > >*' (source is not a pointer to class)"], "errors_after": [], "error_detail": "In file included from /usr/include/c++/9/cassert:44,\n./util/cast_util.h: In instantiation of 'DestClass* rocksdb::static_cast_with_check(SrcClass*) [with DestClass = rocksdb::KeyLockWaiter; SrcClass = void]':\n./util/cast_util.h:23:17: error: cannot dynamic_cast 'x' (of type 'void*') to type 'struct rocksdb::KeyLockWaiter*' (source is not a pointer to class)\n   23 |   assert(ret == dynamic_cast<DestClass*>(x));\n      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~", "time": 4.457043647766113, "evaluation_mode": "full"}, "timestamp": "2025-08-20 17:30:26"}
{"instance_index": 19, "error_index": 1, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "./util/cast_util.h:23:17: error: cannot dynamic_cast 'x' (of type 'void*') to type 'struct alternative_rocksdb_ns::KeyLockWaiter*' (source is not a pointer to class)", "patches": [{"error_line": "./util/cast_util.h:23:17: error: cannot dynamic_cast 'x' (of type 'void*') to type 'struct alternative_rocksdb_ns::KeyLockWaiter*' (source is not a pointer to class)", "file_path": "./util/cast_util.h", "start_line": 23, "end_line": 23, "original_code": "  assert(ret == dynamic_cast<DestClass*>(x));", "fixed_code": "  if constexpr (!std::is_void<SrcClass>::value) {\n    assert(ret == dynamic_cast<DestClass*>(x));\n  }", "confidence": 0.5, "explanation": ""}], "errors_before": ["./util/cast_util.h:23:17: error: cannot dynamic_cast 'x' (of type 'void*') to type 'struct alternative_rocksdb_ns::KeyLockWaiter*' (source is not a pointer to class)", "./util/cast_util.h:23:17: error: cannot dynamic_cast 'x' (of type 'void*') to type 'class std::unordered_map<unsigned int, std::shared_ptr<alternative_rocksdb_ns::LockMap>, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<std::pair<const unsigned int, std::shared_ptr<alternative_rocksdb_ns::LockMap> > > >*' (source is not a pointer to class)"], "errors_after": [], "error_detail": "In file included from /usr/include/c++/9/cassert:44,\n./util/cast_util.h: In instantiation of 'DestClass* alternative_rocksdb_ns::static_cast_with_check(SrcClass*) [with DestClass = alternative_rocksdb_ns::KeyLockWaiter; SrcClass = void]':\n./util/cast_util.h:23:17: error: cannot dynamic_cast 'x' (of type 'void*') to type 'struct alternative_rocksdb_ns::KeyLockWaiter*' (source is not a pointer to class)\n   23 |   assert(ret == dynamic_cast<DestClass*>(x));\n      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~", "time": 4.193324089050293, "evaluation_mode": "full"}, "timestamp": "2025-08-20 17:31:28"}
{"instance_index": 16, "error_index": 2, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "./util/cast_util.h:23:17: error: cannot dynamic_cast 'x' (of type 'void*') to type 'class std::unordered_map<unsigned int, std::shared_ptr<rocksdb::LockMap>, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<std::pair<const unsigned int, std::shared_ptr<rocksdb::LockMap> > > >*' (source is not a pointer to class)", "patches": [{"error_line": "./util/cast_util.h:23:17: error: cannot dynamic_cast 'x' (of type 'void*') to type 'class std::unordered_map<unsigned int, std::shared_ptr<rocksdb::LockMap>, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<std::pair<const unsigned int, std::shared_ptr<rocksdb::LockMap> > > >*' (source is not a pointer to class)", "file_path": "./util/cast_util.h", "start_line": 23, "end_line": 23, "original_code": "  assert(ret == dynamic_cast<DestClass*>(x));", "fixed_code": "  if constexpr (!std::is_void<SrcClass>::value) {\n    assert(ret == dynamic_cast<DestClass*>(x));\n  }", "confidence": 0.5, "explanation": ""}], "errors_before": ["./util/cast_util.h:23:17: error: cannot dynamic_cast 'x' (of type 'void*') to type 'struct rocksdb::KeyLockWaiter*' (source is not a pointer to class)", "./util/cast_util.h:23:17: error: cannot dynamic_cast 'x' (of type 'void*') to type 'class std::unordered_map<unsigned int, std::shared_ptr<rocksdb::LockMap>, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<std::pair<const unsigned int, std::shared_ptr<rocksdb::LockMap> > > >*' (source is not a pointer to class)"], "errors_after": [], "error_detail": "./util/cast_util.h: In instantiation of 'DestClass* rocksdb::static_cast_with_check(SrcClass*) [with DestClass = std::unordered_map<unsigned int, std::shared_ptr<rocksdb::LockMap>, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<std::pair<const unsigned int, std::shared_ptr<rocksdb::LockMap> > > >; SrcClass = void]':\n./util/cast_util.h:23:17: error: cannot dynamic_cast 'x' (of type 'void*') to type 'class std::unordered_map<unsigned int, std::shared_ptr<rocksdb::LockMap>, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<std::pair<const unsigned int, std::shared_ptr<rocksdb::LockMap> > > >*' (source is not a pointer to class)\nmkdir -p utilities/cassandra && g++  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -fno-builtin-memcmp -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -march=native  -DHAVE_UINT128_EXTENSION  -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c utilities/cassandra/test_utils.cc -o utilities/cassandra/test_utils.o\nmkdir -p table && g++  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -fno-builtin-memcmp -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -march=native  -DHAVE_UINT128_EXTENSION  -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c table/mock_table.cc -o table/mock_table.o\nmkdir -p third-party/gtest-1.8.1/fused-src/gtest && g++  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -fno-builtin-memcmp -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -march=native  -DHAVE_UINT128_EXTENSION  -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c third-party/gtest-1.8.1/fused-src/gtest/gtest-all.cc -o third-party/gtest-1.8.1/fused-src/gtest/gtest-all.o\nmkdir -p tools && g++  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -fno-builtin-memcmp -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -march=native  -DHAVE_UINT128_EXTENSION  -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c tools/db_bench.cc -o tools/db_bench.o", "time": 5.994133949279785, "evaluation_mode": "full"}, "timestamp": "2025-08-20 18:36:14"}
{"instance_index": 19, "error_index": 2, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "./util/cast_util.h:23:17: error: cannot dynamic_cast 'x' (of type 'void*') to type 'class std::unordered_map<unsigned int, std::shared_ptr<alternative_rocksdb_ns::LockMap>, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<std::pair<const unsigned int, std::shared_ptr<alternative_rocksdb_ns::LockMap> > > >*' (source is not a pointer to class)", "patches": [{"error_line": "./util/cast_util.h:23:17: error: cannot dynamic_cast 'x' (of type 'void*') to type 'class std::unordered_map<unsigned int, std::shared_ptr<alternative_rocksdb_ns::LockMap>, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<std::pair<const unsigned int, std::shared_ptr<alternative_rocksdb_ns::LockMap> > > >*' (source is not a pointer to class)", "file_path": "./util/cast_util.h", "start_line": 23, "end_line": 24, "original_code": "  assert(ret == dynamic_cast<DestClass*>(x));\n#endif", "fixed_code": "  if constexpr (!std::is_same_v<SrcClass, void>) {\n    assert(ret == dynamic_cast<DestClass*>(x));\n  }\n#endif", "confidence": 0.5, "explanation": ""}], "errors_before": ["./util/cast_util.h:23:17: error: cannot dynamic_cast 'x' (of type 'void*') to type 'struct alternative_rocksdb_ns::KeyLockWaiter*' (source is not a pointer to class)", "./util/cast_util.h:23:17: error: cannot dynamic_cast 'x' (of type 'void*') to type 'class std::unordered_map<unsigned int, std::shared_ptr<alternative_rocksdb_ns::LockMap>, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<std::pair<const unsigned int, std::shared_ptr<alternative_rocksdb_ns::LockMap> > > >*' (source is not a pointer to class)"], "errors_after": [], "error_detail": "./util/cast_util.h: In instantiation of 'DestClass* alternative_rocksdb_ns::static_cast_with_check(SrcClass*) [with DestClass = std::unordered_map<unsigned int, std::shared_ptr<alternative_rocksdb_ns::LockMap>, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<std::pair<const unsigned int, std::shared_ptr<alternative_rocksdb_ns::LockMap> > > >; SrcClass = void]':\n./util/cast_util.h:23:17: error: cannot dynamic_cast 'x' (of type 'void*') to type 'class std::unordered_map<unsigned int, std::shared_ptr<alternative_rocksdb_ns::LockMap>, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<std::pair<const unsigned int, std::shared_ptr<alternative_rocksdb_ns::LockMap> > > >*' (source is not a pointer to class)\nmkdir -p db && g++  -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -fno-builtin-memcmp -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -march=native  -DHAVE_UINT128_EXTENSION -fno-elide-constructors  -isystem third-party/gtest-1.8.1/fused-src -DTEST_UINT128_COMPAT=1 -DROCKSDB_MODIFY_NPHASH=1 -DROCKSDB_NAMESPACE=alternative_rocksdb_ns -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -DROCKSDB_ASSERT_STATUS_CHECKED -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c db/range_del_aggregator_bench.cc -o db/range_del_aggregator_bench.o\nmkdir -p memtable && g++  -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -fno-builtin-memcmp -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -march=native  -DHAVE_UINT128_EXTENSION -fno-elide-constructors  -isystem third-party/gtest-1.8.1/fused-src -DTEST_UINT128_COMPAT=1 -DROCKSDB_MODIFY_NPHASH=1 -DROCKSDB_NAMESPACE=alternative_rocksdb_ns -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -DROCKSDB_ASSERT_STATUS_CHECKED -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c memtable/memtablerep_bench.cc -o memtable/memtablerep_bench.o\nmkdir -p table && g++  -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -fno-builtin-memcmp -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -march=native  -DHAVE_UINT128_EXTENSION -fno-elide-constructors  -isystem third-party/gtest-1.8.1/fused-src -DTEST_UINT128_COMPAT=1 -DROCKSDB_MODIFY_NPHASH=1 -DROCKSDB_NAMESPACE=alternative_rocksdb_ns -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -DROCKSDB_ASSERT_STATUS_CHECKED -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c table/table_reader_bench.cc -o table/table_reader_bench.o", "time": 5.49935507774353, "evaluation_mode": "full"}, "timestamp": "2025-08-20 18:39:02"}
{"instance_index": 20, "error_index": 1, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "include/rocksdb/user_defined_index.h:116:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions''", "patches": [{"error_line": "include/rocksdb/user_defined_index.h:116:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions''", "file_path": "include/rocksdb/user_defined_index.h", "start_line": 18, "end_line": 18, "original_code": "", "fixed_code": "#include \"rocksdb/options.h\"", "confidence": 0.5, "explanation": ""}], "errors_before": ["include/rocksdb/user_defined_index.h:116:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?", "./include/rocksdb/user_defined_index.h:116:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?", "table/block_based/user_defined_index_wrapper.h:218:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "rocksdb/user_defined_index.h:116:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?"], "errors_after": [], "error_detail": "In file included from <stdin>:1:\ninclude/rocksdb/user_defined_index.h:116:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions''\n  116 |       const ReadOptions& read_options) = 0;\n      |             ^~~~~~~~~~~\n      |             DBOptions", "time": 9.752563953399658, "evaluation_mode": "full"}, "timestamp": "2025-08-20 19:03:11"}
{"instance_index": 20, "error_index": 3, "error_result": {"is_successful": false, "is_exact_match": false, "is_valid": false, "error_line": "table/block_based/user_defined_index_wrapper.h:218:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "patches": [{"error_line": "table/block_based/user_defined_index_wrapper.h:218:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "file_path": "table/block_based/user_defined_index_wrapper.h", "start_line": 218, "end_line": 218, "original_code": "        udi_reader_->NewIterator(read_options);", "fixed_code": "        std::unique_ptr<UserDefinedIndexIterator> udi_iter =\n            udi_reader_->NewIterator(read_options);", "confidence": 0.5, "explanation": ""}], "errors_before": ["include/rocksdb/user_defined_index.h:116:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?", "./include/rocksdb/user_defined_index.h:116:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?", "table/block_based/user_defined_index_wrapper.h:218:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "rocksdb/user_defined_index.h:116:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?"], "errors_after": ["./table/block_based/user_defined_index_wrapper.h:218:51: error: expected primary-expression before 'udi_iter'"], "error_detail": "table/block_based/user_defined_index_wrapper.h:218:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'\n  218 |         udi_reader_->NewIterator(read_options);\n      |                                  ^~~~~~~~~~~~\n      |                                  |\n      |                                  const rocksdb::ReadOptions", "time": 12.832427263259888, "evaluation_mode": "full"}, "timestamp": "2025-08-20 19:06:10"}
{"instance_index": 22, "error_index": 1, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "include/rocksdb/user_defined_index.h:93:30: error: 'ScanOptions' does not name a type; did you mean 'DBOptions''", "patches": [{"error_line": "include/rocksdb/user_defined_index.h:93:30: error: 'ScanOptions' does not name a type; did you mean 'DBOptions''", "file_path": "include/rocksdb/user_defined_index.h", "start_line": 18, "end_line": 18, "original_code": "", "fixed_code": "#include \"rocksdb/options.h\"", "confidence": 0.5, "explanation": ""}], "errors_before": ["include/rocksdb/user_defined_index.h:93:30: error: 'ScanOptions' does not name a type; did you mean 'DBOptions'?", "include/rocksdb/user_defined_index.h:123:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?", "./include/rocksdb/user_defined_index.h:93:30: error: 'ScanOptions' does not name a type; did you mean 'DBOptions'?", "./include/rocksdb/user_defined_index.h:123:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?", "table/block_based/user_defined_index_wrapper.h:182:39: error: cannot convert 'const rocksdb::ScanOptions*' to 'const int*'", "table/block_based/user_defined_index_wrapper.h:223:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "rocksdb/user_defined_index.h:93:30: error: 'ScanOptions' does not name a type; did you mean 'DBOptions'?", "rocksdb/user_defined_index.h:123:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?"], "errors_after": [], "error_detail": "In file included from <stdin>:1:\ninclude/rocksdb/user_defined_index.h:93:30: error: 'ScanOptions' does not name a type; did you mean 'DBOptions''\n   93 |   virtual void Prepare(const ScanOptions scan_opts[], size_t num_opts) = 0;\n      |                              ^~~~~~~~~~~\n      |                              DBOptions", "time": 6.338176012039185, "evaluation_mode": "full"}, "timestamp": "2025-08-20 19:09:26"}
{"instance_index": 21, "error_index": 1, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "include/rocksdb/user_defined_index.h:119:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions''", "patches": [{"error_line": "include/rocksdb/user_defined_index.h:119:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions''", "file_path": "include/rocksdb/user_defined_index.h", "start_line": 12, "end_line": 12, "original_code": "#include <string>", "fixed_code": "#include <string>\n#include \"rocksdb/options.h\"", "confidence": 0.5, "explanation": ""}], "errors_before": ["include/rocksdb/user_defined_index.h:119:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?", "./include/rocksdb/user_defined_index.h:119:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?", "table/block_based/user_defined_index_wrapper.h:219:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "rocksdb/user_defined_index.h:119:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?"], "errors_after": [], "error_detail": "In file included from <stdin>:1:\ninclude/rocksdb/user_defined_index.h:119:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions''\n  119 |       const ReadOptions& read_options) = 0;\n      |             ^~~~~~~~~~~\n      |             DBOptions", "time": 9.921724557876587, "evaluation_mode": "full"}, "timestamp": "2025-08-20 19:21:08"}
{"instance_index": 23, "error_index": 1, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "include/rocksdb/user_defined_index.h:88:30: error: 'ScanOptions' does not name a type", "patches": [{"error_line": "include/rocksdb/user_defined_index.h:88:30: error: 'ScanOptions' does not name a type", "file_path": "include/rocksdb/user_defined_index.h", "start_line": 6, "end_line": 6, "original_code": "", "fixed_code": "#include \"rocksdb/options.h\"", "confidence": 0.5, "explanation": ""}], "errors_before": ["include/rocksdb/user_defined_index.h:88:30: error: 'ScanOptions' does not name a type", "include/rocksdb/user_defined_index.h:118:13: error: 'ReadOptions' does not name a type", "include/rocksdb/user_defined_index.h:126:53: error: expected class-name before '{' token", "./include/rocksdb/user_defined_index.h:88:30: error: 'ScanOptions' does not name a type", "./include/rocksdb/user_defined_index.h:118:13: error: 'ReadOptions' does not name a type", "./include/rocksdb/user_defined_index.h:126:53: error: expected class-name before '{' token", "table/block_based/user_defined_index_wrapper.h:182:39: error: cannot convert 'const rocksdb::ScanOptions*' to 'const int*'", "table/block_based/user_defined_index_wrapper.h:223:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "rocksdb/user_defined_index.h:88:30: error: 'ScanOptions' does not name a type", "rocksdb/user_defined_index.h:118:13: error: 'ReadOptions' does not name a type", "rocksdb/user_defined_index.h:126:53: error: expected class-name before '{' token"], "errors_after": [], "error_detail": "In file included from <stdin>:1:\ninclude/rocksdb/user_defined_index.h:88:30: error: 'ScanOptions' does not name a type\n   88 |   virtual void Prepare(const ScanOptions scan_opts[], size_t num_opts) = 0;\n      |                              ^~~~~~~~~~~", "time": 8.480854988098145, "evaluation_mode": "full"}, "timestamp": "2025-08-20 19:21:16"}
{"instance_index": 21, "error_index": 3, "error_result": {"is_successful": false, "is_exact_match": false, "is_valid": false, "error_line": "table/block_based/user_defined_index_wrapper.h:219:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "patches": [{"error_line": "table/block_based/user_defined_index_wrapper.h:219:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "file_path": "table/block_based/user_defined_index_wrapper.h", "start_line": 219, "end_line": 219, "original_code": "        udi_reader_->NewIterator(read_options);", "fixed_code": "        std::unique_ptr<UserDefinedIndexIterator> udi_iter =\n            udi_reader_->NewIterator(read_options);", "confidence": 0.5, "explanation": ""}], "errors_before": ["include/rocksdb/user_defined_index.h:119:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?", "./include/rocksdb/user_defined_index.h:119:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?", "table/block_based/user_defined_index_wrapper.h:219:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "rocksdb/user_defined_index.h:119:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?"], "errors_after": ["./table/block_based/user_defined_index_wrapper.h:219:51: error: expected primary-expression before 'udi_iter'"], "error_detail": "table/block_based/user_defined_index_wrapper.h:219:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'\n  219 |         udi_reader_->NewIterator(read_options);\n      |                                  ^~~~~~~~~~~~\n      |                                  |\n      |                                  const rocksdb::ReadOptions", "time": 8.62087893486023, "evaluation_mode": "full"}, "timestamp": "2025-08-20 19:24:33"}
{"instance_index": 24, "error_index": 1, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "include/rocksdb/user_defined_index.h:114:13: error: 'ReadOptions' does not name a type", "patches": [{"error_line": "include/rocksdb/user_defined_index.h:114:13: error: 'ReadOptions' does not name a type", "file_path": "include/rocksdb/user_defined_index.h", "start_line": 8, "end_line": 8, "original_code": "#include <string>", "fixed_code": "#include <string>\n#include \"rocksdb/options.h\"", "confidence": 0.5, "explanation": ""}], "errors_before": ["include/rocksdb/user_defined_index.h:114:13: error: 'ReadOptions' does not name a type", "include/rocksdb/user_defined_index.h:122:53: error: expected class-name before '{' token", "./include/rocksdb/user_defined_index.h:114:13: error: 'ReadOptions' does not name a type", "./include/rocksdb/user_defined_index.h:122:53: error: expected class-name before '{' token", "table/block_based/user_defined_index_wrapper.h:219:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "rocksdb/user_defined_index.h:114:13: error: 'ReadOptions' does not name a type", "rocksdb/user_defined_index.h:122:53: error: expected class-name before '{' token"], "errors_after": [], "error_detail": "In file included from <stdin>:1:\ninclude/rocksdb/user_defined_index.h:114:13: error: 'ReadOptions' does not name a type\n  114 |       const ReadOptions& read_options) = 0;\n      |             ^~~~~~~~~~~", "time": 7.871303558349609, "evaluation_mode": "full"}, "timestamp": "2025-08-20 19:26:31"}
{"instance_index": 22, "error_index": 2, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "include/rocksdb/user_defined_index.h:123:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions''", "patches": [{"error_line": "include/rocksdb/user_defined_index.h:123:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions''", "file_path": "include/rocksdb/user_defined_index.h", "start_line": 17, "end_line": 17, "original_code": "#include \"rocksdb/status.h\"", "fixed_code": "#include \"rocksdb/status.h\"\n#include \"rocksdb/options.h\"", "confidence": 0.5, "explanation": ""}], "errors_before": ["include/rocksdb/user_defined_index.h:93:30: error: 'ScanOptions' does not name a type; did you mean 'DBOptions'?", "include/rocksdb/user_defined_index.h:123:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?", "./include/rocksdb/user_defined_index.h:93:30: error: 'ScanOptions' does not name a type; did you mean 'DBOptions'?", "./include/rocksdb/user_defined_index.h:123:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?", "table/block_based/user_defined_index_wrapper.h:182:39: error: cannot convert 'const rocksdb::ScanOptions*' to 'const int*'", "table/block_based/user_defined_index_wrapper.h:223:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "rocksdb/user_defined_index.h:93:30: error: 'ScanOptions' does not name a type; did you mean 'DBOptions'?", "rocksdb/user_defined_index.h:123:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?"], "errors_after": [], "error_detail": "include/rocksdb/user_defined_index.h:123:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions''\n  123 |       const ReadOptions& read_options) = 0;\n      |             ^~~~~~~~~~~\n      |             DBOptions", "time": 7.373201370239258, "evaluation_mode": "full"}, "timestamp": "2025-08-20 19:33:10"}
{"instance_index": 27, "error_index": 1, "error_result": {"is_successful": false, "is_exact_match": false, "is_valid": false, "error_line": "/__w/rocksdb/rocksdb/db/table_cache.cc:127:38: error: 'kRandom' is not a member of 'rocksdb::FSRandomAccessFile'", "patches": [{"error_line": "/__w/rocksdb/rocksdb/db/table_cache.cc:127:38: error: 'kRandom' is not a member of 'rocksdb::FSRandomAccessFile'", "file_path": "include/rocksdb/file_system.h", "start_line": 914, "end_line": 1054, "original_code": "class FSRandomAccessFile {\n public:\n  FSRandomAccessFile() {}\n\n  virtual ~FSRandomAccessFile() {}\n\n  // Read up to \"n\" bytes from the file starting at \"offset\".\n  // \"scratch[0..n-1]\" may be written by this routine.  Sets \"*result\"\n  // to the data that was read (including if fewer than \"n\" bytes were\n  // successfully read).  May set \"*result\" to point at data in\n  // \"scratch[0..n-1]\", so \"scratch[0..n-1]\" must be live when\n  // \"*result\" is used.  If an error was encountered, returns a non-OK\n  // status.\n  //\n  // After call, result->size() < n only if end of file has been\n  // reached (or non-OK status). Read might fail if called again after\n  // first result->size() < n.\n  //\n  // Safe for concurrent use by multiple threads.\n  // If Direct I/O enabled, offset, n, and scratch should be aligned properly.\n  virtual IOStatus Read(uint64_t offset, size_t n, const IOOptions& options,\n                        Slice* result, char* scratch,\n                        IODebugContext* dbg) const = 0;\n\n  // Readahead the file starting from offset by n bytes for caching.\n  // If it's not implemented (default: `NotSupported`), RocksDB will create\n  // internal prefetch buffer to improve read performance.\n  virtual IOStatus Prefetch(uint64_t /*offset*/, size_t /*n*/,\n                            const IOOptions& /*options*/,\n                            IODebugContext* /*dbg*/) {\n    return IOStatus::NotSupported(\"Prefetch\");\n  }\n\n  // Read a bunch of blocks as described by reqs. The blocks can\n  // optionally be read in parallel. This is a synchronous call, i.e it\n  // should return after all reads have completed. The reads will be\n  // non-overlapping but can be in any order. If the function return Status\n  // is not ok, status of individual requests will be ignored and return\n  // status will be assumed for all read requests. The function return status\n  // is only meant for errors that occur before processing individual read\n  // requests.\n  virtual IOStatus MultiRead(FSReadRequest* reqs, size_t num_reqs,\n                             const IOOptions& options, IODebugContext* dbg) {\n    assert(reqs != nullptr);\n    for (size_t i = 0; i < num_reqs; ++i) {\n      FSReadRequest& req = reqs[i];\n      req.status =\n          Read(req.offset, req.len, options, &req.result, req.scratch, dbg);\n    }\n    return IOStatus::OK();\n  }\n\n  // Tries to get an unique ID for this file that will be the same each time\n  // the file is opened (and will stay the same while the file is open).\n  // Furthermore, it tries to make this ID at most \"max_size\" bytes. If such an\n  // ID can be created this function returns the length of the ID and places it\n  // in \"id\"; otherwise, this function returns 0, in which case \"id\"\n  // may not have been modified.\n  //\n  // This function guarantees, for IDs from a given environment, two unique ids\n  // cannot be made equal to each other by adding arbitrary bytes to one of\n  // them. That is, no unique ID is the prefix of another.\n  //\n  // This function guarantees that the returned ID will not be interpretable as\n  // a single varint.\n  //\n  // Note: these IDs are only valid for the duration of the process.\n  virtual size_t GetUniqueId(char* /*id*/, size_t /*max_size*/) const {\n    return 0;  // Default implementation to prevent issues with backwards\n               // compatibility.\n  }\n\n  virtual void Hint(AccessPattern /*pattern*/) {}\n\n  // Indicates the upper layers if the current RandomAccessFile implementation\n  // uses direct IO.\n  virtual bool use_direct_io() const { return false; }\n\n  // Use the returned alignment value to allocate\n  // aligned buffer for Direct I/O\n  virtual size_t GetRequiredBufferAlignment() const { return kDefaultPageSize; }\n\n  // Remove any kind of caching of data from the offset to offset+length\n  // of this file. If the length is 0, then it refers to the end of file.\n  // If the system is not caching the file contents, then this is a noop.\n  virtual IOStatus InvalidateCache(size_t /*offset*/, size_t /*length*/) {\n    return IOStatus::NotSupported(\"InvalidateCache not supported.\");\n  }\n\n  // This API reads the requested data in FSReadRequest asynchronously. This is\n  // a asynchronous call, i.e it should return after submitting the request.\n  //\n  // When the read request is completed, callback function specified in cb\n  // should be called with arguments cb_arg and the result populated in\n  // FSReadRequest with result and status fileds updated by FileSystem.\n  // cb_arg should be used by the callback to track the original request\n  // submitted.\n  //\n  // This API should also populate io_handle which should be used by\n  // underlying FileSystem to store the context in order to distinguish the read\n  // requests at their side and provide the custom deletion function in del_fn.\n  // RocksDB guarantees that the del_fn for io_handle will be called after\n  // receiving the callback. Furthermore, RocksDB guarantees that if it calls\n  // the Poll API for this io_handle, del_fn will be called after the Poll\n  // returns. RocksDB is responsible for managing the lifetime of io_handle.\n  //\n  // req contains the request offset and size passed as input parameter of read\n  // request and result and status fields are output parameter set by underlying\n  // FileSystem. The data should always be read into scratch field.\n  //\n  // How to enable:\n  // In order to enable ReadAsync, FS needs to override SupportedOps() API and\n  // set FSSupportedOps::kAsyncIO in SupportedOps() as:\n  //  {\n  //    supported_ops |= (1 << FSSupportedOps::kAsyncIO);\n  //  }\n  //\n  // Note: If FS supports ReadAsync API, it should also override Poll and\n  // AbortIO API.\n  //\n  // Default implementation is to read the data synchronously.\n  virtual IOStatus ReadAsync(FSReadRequest& req, const IOOptions& opts,\n                             std::function<void(FSReadRequest&, void*)> cb,\n                             void* cb_arg, void** /*io_handle*/,\n                             IOHandleDeleter* /*del_fn*/, IODebugContext* dbg) {\n    req.status =\n        Read(req.offset, req.len, opts, &(req.result), req.scratch, dbg);\n    cb(req, cb_arg);\n    return IOStatus::OK();\n  }\n\n  // EXPERIMENTAL\n  // When available, returns the actual temperature for the file. This is\n  // useful in case some outside process moves a file from one tier to another,\n  // though the temperature is generally expected not to change while a file is\n  // open.\n  virtual Temperature GetTemperature() const { return Temperature::kUnknown; }\n\n  // If you're adding methods here, remember to add them to\n  // RandomAccessFileWrapper too.\n};", "fixed_code": "class FSRandomAccessFile {\n public:\n  FSRandomAccessFile() {}\n\n  virtual ~FSRandomAccessFile() {}\n\n  // Read up to \"n\" bytes from the file starting at \"offset\".\n  // \"scratch[0..n-1]\" may be written by this routine.  Sets \"*result\"\n  // to the data that was read (including if fewer than \"n\" bytes were\n  // successfully read).  May set \"*result\" to point at data in\n  // \"scratch[0..n-1]\", so \"scratch[0..n-1]\" must be live when\n  // \"*result\" is used.  If an error was encountered, returns a non-OK\n  // status.\n  //\n  // After call, result->size() < n only if end of file has been\n  // reached (or non-OK status). Read might fail if called again after\n  // first result->size() < n.\n  //\n  // Safe for concurrent use by multiple threads.\n  // If Direct I/O enabled, offset, n, and scratch should be aligned properly.\n  virtual IOStatus Read(uint64_t offset, size_t n, const IOOptions& options,\n                        Slice* result, char* scratch,\n                        IODebugContext* dbg) const = 0;\n\n  // Readahead the file starting from offset by n bytes for caching.\n  // If it's not implemented (default: `NotSupported`), RocksDB will create\n  // internal prefetch buffer to improve read performance.\n  virtual IOStatus Prefetch(uint64_t /*offset*/, size_t /*n*/,\n                            const IOOptions& /*options*/,\n                            IODebugContext* /*dbg*/) {\n    return IOStatus::NotSupported(\"Prefetch\");\n  }\n\n  // Read a bunch of blocks as described by reqs. The blocks can\n  // optionally be read in parallel. This is a synchronous call, i.e it\n  // should return after all reads have completed. The reads will be\n  // non-overlapping but can be in any order. If the function return Status\n  // is not ok, status of individual requests will be ignored and return\n  // status will be assumed for all read requests. The function return status\n  // is only meant for errors that occur before processing individual read\n  // requests.\n  virtual IOStatus MultiRead(FSReadRequest* reqs, size_t num_reqs,\n                             const IOOptions& options, IODebugContext* dbg) {\n    assert(reqs != nullptr);\n    for (size_t i = 0; i < num_reqs; ++i) {\n      FSReadRequest& req = reqs[i];\n      req.status =\n          Read(req.offset, req.len, options, &req.result, req.scratch, dbg);\n    }\n    return IOStatus::OK();\n  }\n\n  // Tries to get an unique ID for this file that will be the same each time\n  // the file is opened (and will stay the same while the file is open).\n  // Furthermore, it tries to make this ID at most \"max_size\" bytes. If such an\n  // ID can be created this function returns the length of the ID and places it\n  // in \"id\"; otherwise, this function returns 0, in which case \"id\"\n  // may not have been modified.\n  //\n  // This function guarantees, for IDs from a given environment, two unique ids\n  // cannot be made equal to each other by adding arbitrary bytes to one of\n  // them. That is, no unique ID is the prefix of another.\n  //\n  // This function guarantees that the returned ID will not be interpretable as\n  // a single varint.\n  //\n  // Note: these IDs are only valid for the duration of the process.\n  virtual size_t GetUniqueId(char* /*id*/, size_t /*max_size*/) const {\n    return 0;  // Default implementation to prevent issues with backwards\n               // compatibility.\n  }\n\n  // Enum for access pattern hints\n  enum AccessPatternHint {\n    kNormal,\n    kRandom,\n    kSequential,\n    kWillNeed,\n    kDontNeed\n  };\n\n  virtual void Hint(AccessPattern /*pattern*/) {}\n\n  // Indicates the upper layers if the current RandomAccessFile implementation\n  // uses direct IO.\n  virtual bool use_direct_io() const { return false; }\n\n  // Use the returned alignment value to allocate\n  // aligned buffer for Direct I/O\n  virtual size_t GetRequiredBufferAlignment() const { return kDefaultPageSize; }\n\n  // Remove any kind of caching of data from the offset to offset+length\n  // of this file. If the length is 0, then it refers to the end of file.\n  // If the system is not caching the file contents, then this is a noop.\n  virtual IOStatus InvalidateCache(size_t /*offset*/, size_t /*length*/) {\n    return IOStatus::NotSupported(\"InvalidateCache not supported.\");\n  }\n\n  // This API reads the requested data in FSReadRequest asynchronously. This is\n  // a asynchronous call, i.e it should return after submitting the request.\n  //\n  // When the read request is completed, callback function specified in cb\n  // should be called with arguments cb_arg and the result populated in\n  // FSReadRequest with result and status fileds updated by FileSystem.\n  // cb_arg should be used by the callback to track the original request\n  // submitted.\n  //\n  // This API should also populate io_handle which should be used by\n  // underlying FileSystem to store the context in order to distinguish the read\n  // requests at their side and provide the custom deletion function in del_fn.\n  // RocksDB guarantees that the del_fn for io_handle will be called after\n  // receiving the callback. Furthermore, RocksDB guarantees that if it calls\n  // the Poll API for this io_handle, del_fn will be called after the Poll\n  // returns. RocksDB is responsible for managing the lifetime of io_handle.\n  //\n  // req contains the request offset and size passed as input parameter of read\n  // request and result and status fields are output parameter set by underlying\n  // FileSystem. The data should always be read into scratch field.\n  //\n  // How to enable:\n  // In order to enable ReadAsync, FS needs to override SupportedOps() API and\n  // set FSSupportedOps::kAsyncIO in SupportedOps() as:\n  //  {\n  //    supported_ops |= (1 << FSSupportedOps::kAsyncIO);\n  //  }\n  //\n  // Note: If FS supports ReadAsync API, it should also override Poll and\n  // AbortIO API.\n  //\n  // Default implementation is to read the data synchronously.\n  virtual IOStatus ReadAsync(FSReadRequest& req, const IOOptions& opts,\n                             std::function<void(FSReadRequest&, void*)> cb,\n                             void* cb_arg, void** /*io_handle*/,\n                             IOHandleDeleter* /*del_fn*/, IODebugContext* dbg) {\n    req.status =\n        Read(req.offset, req.len, opts, &(req.result), req.scratch, dbg);\n    cb(req, cb_arg);\n    return IOStatus::OK();\n  }\n\n  // EXPERIMENTAL\n  // When available, returns the actual temperature for the file. This is\n  // useful in case some outside process moves a file from one tier to another,\n  // though the temperature is generally expected not to change while a file is\n  // open.\n  virtual Temperature GetTemperature() const { return Temperature::kUnknown; }\n\n  // If you're adding methods here, remember to add them to\n  // RandomAccessFileWrapper too.\n};", "confidence": 0.5, "explanation": ""}], "errors_before": ["/tmp/rocksdb_repo_temp_27_evyb2u5i/db/table_cache.cc:127:38: error: 'kRandom' is not a member of 'rocksdb::FSRandomAccessFile'"], "errors_after": ["/tmp/rocksdb_repo_temp_27_evyb2u5i/db/table_cache.cc:127:38: error: cannot convert 'rocksdb::FSRandomAccessFile::AccessPatternHint' to 'rocksdb::AccessPattern' {aka 'rocksdb::Env::AccessPattern'}"], "error_detail": "/__w/rocksdb/rocksdb/db/table_cache.cc: In member function 'rocksdb::Status rocksdb::TableCache::GetTableReader(const rocksdb::ReadOptions&, const rocksdb::FileOptions&, const rocksdb::InternalKeyComparator&, const rocksdb::FileMetaData&, bool, rocksdb::HistogramImpl*, std::unique_ptr<rocksdb::TableReader>*, const rocksdb::MutableCFOptions&, bool, int, bool, size_t, rocksdb::Temperature)':\n/__w/rocksdb/rocksdb/db/table_cache.cc:127:38: error: 'kRandom' is not a member of 'rocksdb::FSRandomAccessFile'\n  127 |       file->Hint(FSRandomAccessFile::kRandom);\n      |                                      ^~~~~~~", "time": 75.52536296844482, "evaluation_mode": "full"}, "timestamp": "2025-08-20 19:37:35"}
{"instance_index": 23, "error_index": 2, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "include/rocksdb/user_defined_index.h:118:13: error: 'ReadOptions' does not name a type", "patches": [{"error_line": "include/rocksdb/user_defined_index.h:118:13: error: 'ReadOptions' does not name a type", "file_path": "include/rocksdb/user_defined_index.h", "start_line": 8, "end_line": 8, "original_code": "", "fixed_code": "#include \"rocksdb/options.h\"", "confidence": 0.5, "explanation": ""}], "errors_before": ["include/rocksdb/user_defined_index.h:88:30: error: 'ScanOptions' does not name a type", "include/rocksdb/user_defined_index.h:118:13: error: 'ReadOptions' does not name a type", "include/rocksdb/user_defined_index.h:126:53: error: expected class-name before '{' token", "./include/rocksdb/user_defined_index.h:88:30: error: 'ScanOptions' does not name a type", "./include/rocksdb/user_defined_index.h:118:13: error: 'ReadOptions' does not name a type", "./include/rocksdb/user_defined_index.h:126:53: error: expected class-name before '{' token", "table/block_based/user_defined_index_wrapper.h:182:39: error: cannot convert 'const rocksdb::ScanOptions*' to 'const int*'", "table/block_based/user_defined_index_wrapper.h:223:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "rocksdb/user_defined_index.h:88:30: error: 'ScanOptions' does not name a type", "rocksdb/user_defined_index.h:118:13: error: 'ReadOptions' does not name a type", "rocksdb/user_defined_index.h:126:53: error: expected class-name before '{' token"], "errors_after": [], "error_detail": "include/rocksdb/user_defined_index.h:118:13: error: 'ReadOptions' does not name a type\n  118 |       const ReadOptions& read_options) = 0;\n      |             ^~~~~~~~~~~", "time": 15.687965631484985, "evaluation_mode": "full"}, "timestamp": "2025-08-20 19:42:48"}
{"instance_index": 29, "error_index": 1, "error_result": {"is_successful": false, "is_exact_match": false, "is_valid": false, "error_line": "db/table_cache.cc:127:38: error: no member named 'kRandom' in 'rocksdb::FSRandomAccessFile'", "patches": [{"error_line": "db/table_cache.cc:127:38: error: no member named 'kRandom' in 'rocksdb::FSRandomAccessFile'", "file_path": "include/rocksdb/file_system.h", "start_line": 914, "end_line": 914, "original_code": "", "fixed_code": "  // AccessPattern enum for Hint()\n  enum AccessPattern {\n    kNormal = 0,\n    kRandom = 1,\n    kSequential = 2,\n    kWillNeed = 3,\n    kDontNeed = 4\n  };", "confidence": 0.5, "explanation": ""}], "errors_before": ["db/table_cache.cc:127:38: error: no member named 'kRandom' in 'rocksdb::FSRandomAccessFile'"], "errors_after": ["./include/rocksdb/file_system.h:1763:13: error: 'AccessPattern' is a private member of 'rocksdb::FSRandomAccessFile'"], "error_detail": "db/table_cache.cc:127:38: error: no member named 'kRandom' in 'rocksdb::FSRandomAccessFile'\n      file->Hint(FSRandomAccessFile::kRandom);\n                 ~~~~~~~~~~~~~~~~~~~~^\nmkdir -p db/wide && clang++-10  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Wshift-sign-overflow -Wambiguous-reversed-operator -Wimplicit-fallthrough -Wreinterpret-base-class -Wundefined-reinterpret-cast -Werror -I. -I./include -std=c++17  -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -Wshorten-64-to-32 -march=native  -DHAVE_UINT128_EXTENSION -fsanitize=address -mllvm -asan-use-private-alias=1 -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c db/wide/wide_columns.cc -o db/wide/wide_columns.o\nmkdir -p db/wide && clang++-10  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Wshift-sign-overflow -Wambiguous-reversed-operator -Wimplicit-fallthrough -Wreinterpret-base-class -Wundefined-reinterpret-cast -Werror -I. -I./include -std=c++17  -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -Wshorten-64-to-32 -march=native  -DHAVE_UINT128_EXTENSION -fsanitize=address -mllvm -asan-use-private-alias=1 -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c db/wide/wide_columns_helper.cc -o db/wide/wide_columns_helper.o\nmkdir -p db && clang++-10  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Wshift-sign-overflow -Wambiguous-reversed-operator -Wimplicit-fallthrough -Wreinterpret-base-class -Wundefined-reinterpret-cast -Werror -I. -I./include -std=c++17  -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -Wshorten-64-to-32 -march=native  -DHAVE_UINT128_EXTENSION -fsanitize=address -mllvm -asan-use-private-alias=1 -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c db/write_batch.cc -o db/write_batch.o\nmkdir -p db && clang++-10  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Wshift-sign-overflow -Wambiguous-reversed-operator -Wimplicit-fallthrough -Wreinterpret-base-class -Wundefined-reinterpret-cast -Werror -I. -I./include -std=c++17  -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -Wshorten-64-to-32 -march=native  -DHAVE_UINT128_EXTENSION -fsanitize=address -mllvm -asan-use-private-alias=1 -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c db/write_batch_base.cc -o db/write_batch_base.o\nmkdir -p db && clang++-10  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Wshift-sign-overflow -Wambiguous-reversed-operator -Wimplicit-fallthrough -Wreinterpret-base-class -Wundefined-reinterpret-cast -Werror -I. -I./include -std=c++17  -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -Wshorten-64-to-32 -march=native  -DHAVE_UINT128_EXTENSION -fsanitize=address -mllvm -asan-use-private-alias=1 -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c db/write_controller.cc -o db/write_controller.o\nmkdir -p db && clang++-10  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Wshift-sign-overflow -Wambiguous-reversed-operator -Wimplicit-fallthrough -Wreinterpret-base-class -Wundefined-reinterpret-cast -Werror -I. -I./include -std=c++17  -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -Wshorten-64-to-32 -march=native  -DHAVE_UINT128_EXTENSION -fsanitize=address -mllvm -asan-use-private-alias=1 -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c db/write_stall_stats.cc -o db/write_stall_stats.o", "time": 8.674947500228882, "evaluation_mode": "full"}, "timestamp": "2025-08-20 19:44:03"}
{"instance_index": 24, "error_index": 2, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "include/rocksdb/user_defined_index.h:122:53: error: expected class-name before '{' token", "patches": [{"error_line": "include/rocksdb/user_defined_index.h:122:53: error: expected class-name before '{' token", "file_path": "include/rocksdb/user_defined_index.h", "start_line": 8, "end_line": 8, "original_code": "#include <string>", "fixed_code": "#include <string>\n#include \"rocksdb/customizable.h\"", "confidence": 0.5, "explanation": ""}], "errors_before": ["include/rocksdb/user_defined_index.h:114:13: error: 'ReadOptions' does not name a type", "include/rocksdb/user_defined_index.h:122:53: error: expected class-name before '{' token", "./include/rocksdb/user_defined_index.h:114:13: error: 'ReadOptions' does not name a type", "./include/rocksdb/user_defined_index.h:122:53: error: expected class-name before '{' token", "table/block_based/user_defined_index_wrapper.h:219:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "rocksdb/user_defined_index.h:114:13: error: 'ReadOptions' does not name a type", "rocksdb/user_defined_index.h:122:53: error: expected class-name before '{' token"], "errors_after": ["include/rocksdb/user_defined_index.h:115:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?", "./include/rocksdb/user_defined_index.h:115:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?", "table/block_based/user_defined_index_wrapper.h:219:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "rocksdb/user_defined_index.h:115:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?"], "error_detail": "include/rocksdb/user_defined_index.h:122:53: error: expected class-name before '{' token\n  122 | class UserDefinedIndexFactory : public Customizable {\n      |                                                     ^\necho '#include \"include/rocksdb/customizable.h\"' | g++  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -fno-builtin-memcmp -DROCKSDB_FALLOCATE_PRESENT -DGFLAGS=1 -DZLIB -DBZIP2 -DZSTD -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -march=native  -DHAVE_UINT128_EXTENSION  -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof \\\n  -DROCKSDB_NAMESPACE=42 -x c++ -c - -o /dev/null", "time": 12.457876205444336, "evaluation_mode": "full"}, "timestamp": "2025-08-20 19:51:08"}
{"instance_index": 24, "error_index": 5, "error_result": {"is_successful": false, "is_exact_match": false, "is_valid": false, "error_line": "table/block_based/user_defined_index_wrapper.h:219:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "patches": [{"error_line": "table/block_based/user_defined_index_wrapper.h:219:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "file_path": "table/block_based/user_defined_index_wrapper.h", "start_line": 219, "end_line": 219, "original_code": "        udi_reader_->NewIterator(read_options);", "fixed_code": "        std::unique_ptr<UserDefinedIndexIterator> udi_iter =\n            udi_reader_->NewIterator(read_options);", "confidence": 0.5, "explanation": ""}], "errors_before": ["include/rocksdb/user_defined_index.h:114:13: error: 'ReadOptions' does not name a type", "include/rocksdb/user_defined_index.h:122:53: error: expected class-name before '{' token", "./include/rocksdb/user_defined_index.h:114:13: error: 'ReadOptions' does not name a type", "./include/rocksdb/user_defined_index.h:122:53: error: expected class-name before '{' token", "table/block_based/user_defined_index_wrapper.h:219:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "rocksdb/user_defined_index.h:114:13: error: 'ReadOptions' does not name a type", "rocksdb/user_defined_index.h:122:53: error: expected class-name before '{' token"], "errors_after": ["./table/block_based/user_defined_index_wrapper.h:219:51: error: expected primary-expression before 'udi_iter'"], "error_detail": "table/block_based/user_defined_index_wrapper.h:219:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'\n  219 |         udi_reader_->NewIterator(read_options);\n      |                                  ^~~~~~~~~~~~\n      |                                  |\n      |                                  const rocksdb::ReadOptions", "time": 14.0860276222229, "evaluation_mode": "full"}, "timestamp": "2025-08-20 19:54:43"}
{"instance_index": 25, "error_index": 1, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "include/rocksdb/user_defined_index.h:75:53: error: expected class-name before '{' token", "patches": [{"error_line": "include/rocksdb/user_defined_index.h:75:53: error: expected class-name before '{' token", "file_path": "include/rocksdb/user_defined_index.h", "start_line": 8, "end_line": 8, "original_code": "", "fixed_code": "#include \"rocksdb/customizable.h\"", "confidence": 0.5, "explanation": ""}, {"error_line": "include/rocksdb/user_defined_index.h:75:53: error: expected class-name before '{' token", "file_path": "./include/rocksdb/user_defined_index.h", "start_line": 8, "end_line": 8, "original_code": "", "fixed_code": "#include \"rocksdb/customizable.h\"", "confidence": 0.5, "explanation": ""}, {"error_line": "include/rocksdb/user_defined_index.h:75:53: error: expected class-name before '{' token", "file_path": "rocksdb/user_defined_index.h", "start_line": 8, "end_line": 8, "original_code": "", "fixed_code": "#include \"rocksdb/customizable.h\"", "confidence": 0.5, "explanation": ""}], "errors_before": ["include/rocksdb/user_defined_index.h:75:53: error: expected class-name before '{' token", "./include/rocksdb/user_defined_index.h:75:53: error: expected class-name before '{' token", "rocksdb/user_defined_index.h:75:53: error: expected class-name before '{' token"], "errors_after": [], "error_detail": "In file included from <stdin>:1:\ninclude/rocksdb/user_defined_index.h:75:53: error: expected class-name before '{' token\n   75 | class UserDefinedIndexFactory : public Customizable {\n      |                                                     ^", "time": 5.884809970855713, "evaluation_mode": "full"}, "timestamp": "2025-08-20 19:56:13"}
{"instance_index": 30, "error_index": 1, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "db/table_cache.cc:127:38: error: 'kRandom' is not a member of 'alternative_rocksdb_ns::FSRandomAccessFile'", "patches": [{"error_line": "db/table_cache.cc:127:38: error: 'kRandom' is not a member of 'alternative_rocksdb_ns::FSRandomAccessFile'", "file_path": "include/rocksdb/file_system.h", "start_line": 914, "end_line": 914, "original_code": "", "fixed_code": "  // Hint types for file access pattern\n  enum HintType {\n    kNormal,\n    kRandom,\n    kSequential,\n    kWillNeed,\n    kDontNeed\n  };", "confidence": 0.5, "explanation": ""}, {"error_line": "db/table_cache.cc:127:38: error: 'kRandom' is not a member of 'alternative_rocksdb_ns::FSRandomAccessFile'", "file_path": "include/rocksdb/file_system.h", "start_line": 986, "end_line": 986, "original_code": "", "fixed_code": "  // Provide a hint about the access pattern for this file\n  virtual void Hint(HintType /*pattern*/) {}", "confidence": 0.5, "explanation": ""}], "errors_before": ["db/table_cache.cc:127:38: error: 'kRandom' is not a member of 'alternative_rocksdb_ns::FSRandomAccessFile'"], "errors_after": [], "error_detail": "db/table_cache.cc:127:38: error: 'kRandom' is not a member of 'alternative_rocksdb_ns::FSRandomAccessFile'\n  127 |       file->Hint(FSRandomAccessFile::kRandom);\n      |                                      ^~~~~~~\nmkdir -p db && g++  -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -fno-builtin-memcmp -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -march=native  -DHAVE_UINT128_EXTENSION -fno-elide-constructors  -isystem third-party/gtest-1.8.1/fused-src -DTEST_UINT128_COMPAT=1 -DROCKSDB_MODIFY_NPHASH=1 -DROCKSDB_NAMESPACE=alternative_rocksdb_ns -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -DROCKSDB_ASSERT_STATUS_CHECKED -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c db/wal_edit.cc -o db/wal_edit.o\nmkdir -p db && g++  -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -fno-builtin-memcmp -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -march=native  -DHAVE_UINT128_EXTENSION -fno-elide-constructors  -isystem third-party/gtest-1.8.1/fused-src -DTEST_UINT128_COMPAT=1 -DROCKSDB_MODIFY_NPHASH=1 -DROCKSDB_NAMESPACE=alternative_rocksdb_ns -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -DROCKSDB_ASSERT_STATUS_CHECKED -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c db/wal_manager.cc -o db/wal_manager.o\nmkdir -p db/wide && g++  -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -fno-builtin-memcmp -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -march=native  -DHAVE_UINT128_EXTENSION -fno-elide-constructors  -isystem third-party/gtest-1.8.1/fused-src -DTEST_UINT128_COMPAT=1 -DROCKSDB_MODIFY_NPHASH=1 -DROCKSDB_NAMESPACE=alternative_rocksdb_ns -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -DROCKSDB_ASSERT_STATUS_CHECKED -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c db/wide/wide_column_serialization.cc -o db/wide/wide_column_serialization.o\nmkdir -p db/wide && g++  -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -fno-builtin-memcmp -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -march=native  -DHAVE_UINT128_EXTENSION -fno-elide-constructors  -isystem third-party/gtest-1.8.1/fused-src -DTEST_UINT128_COMPAT=1 -DROCKSDB_MODIFY_NPHASH=1 -DROCKSDB_NAMESPACE=alternative_rocksdb_ns -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -DROCKSDB_ASSERT_STATUS_CHECKED -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c db/wide/wide_columns.cc -o db/wide/wide_columns.o\nmkdir -p db/wide && g++  -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -fno-builtin-memcmp -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -march=native  -DHAVE_UINT128_EXTENSION -fno-elide-constructors  -isystem third-party/gtest-1.8.1/fused-src -DTEST_UINT128_COMPAT=1 -DROCKSDB_MODIFY_NPHASH=1 -DROCKSDB_NAMESPACE=alternative_rocksdb_ns -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -DROCKSDB_ASSERT_STATUS_CHECKED -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c db/wide/wide_columns_helper.cc -o db/wide/wide_columns_helper.o\nmkdir -p db && g++  -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -fno-builtin-memcmp -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -march=native  -DHAVE_UINT128_EXTENSION -fno-elide-constructors  -isystem third-party/gtest-1.8.1/fused-src -DTEST_UINT128_COMPAT=1 -DROCKSDB_MODIFY_NPHASH=1 -DROCKSDB_NAMESPACE=alternative_rocksdb_ns -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -DROCKSDB_ASSERT_STATUS_CHECKED -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c db/write_batch.cc -o db/write_batch.o\nmkdir -p db && g++  -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -fno-builtin-memcmp -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -march=native  -DHAVE_UINT128_EXTENSION -fno-elide-constructors  -isystem third-party/gtest-1.8.1/fused-src -DTEST_UINT128_COMPAT=1 -DROCKSDB_MODIFY_NPHASH=1 -DROCKSDB_NAMESPACE=alternative_rocksdb_ns -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -DROCKSDB_ASSERT_STATUS_CHECKED -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c db/write_batch_base.cc -o db/write_batch_base.o", "time": 16.880526065826416, "evaluation_mode": "full"}, "timestamp": "2025-08-20 19:56:45"}
{"instance_index": 22, "error_index": 5, "error_result": {"is_successful": false, "is_exact_match": false, "is_valid": false, "error_line": "table/block_based/user_defined_index_wrapper.h:182:39: error: cannot convert 'const rocksdb::ScanOptions*' to 'const int*'", "patches": [{"error_line": "table/block_based/user_defined_index_wrapper.h:182:39: error: cannot convert 'const rocksdb::ScanOptions*' to 'const int*'", "file_path": "table/block_based/user_defined_index_wrapper.h", "start_line": 181, "end_line": 183, "original_code": "  void Prepare(const std::vector<ScanOptions>* scan_opts) override {\n    udi_iter_->Prepare(scan_opts->data(), scan_opts->size());\n  }", "fixed_code": "  void Prepare(const std::vector<ROCKSDB_NAMESPACE::ScanOptions>* scan_opts) override {\n    udi_iter_->Prepare(scan_opts->data(), scan_opts->size());\n  }", "confidence": 0.5, "explanation": ""}], "errors_before": ["include/rocksdb/user_defined_index.h:93:30: error: 'ScanOptions' does not name a type; did you mean 'DBOptions'?", "include/rocksdb/user_defined_index.h:123:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?", "./include/rocksdb/user_defined_index.h:93:30: error: 'ScanOptions' does not name a type; did you mean 'DBOptions'?", "./include/rocksdb/user_defined_index.h:123:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?", "table/block_based/user_defined_index_wrapper.h:182:39: error: cannot convert 'const rocksdb::ScanOptions*' to 'const int*'", "table/block_based/user_defined_index_wrapper.h:223:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "rocksdb/user_defined_index.h:93:30: error: 'ScanOptions' does not name a type; did you mean 'DBOptions'?", "rocksdb/user_defined_index.h:123:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?"], "errors_after": ["include/rocksdb/user_defined_index.h:93:30: error: 'ScanOptions' does not name a type; did you mean 'DBOptions'?", "include/rocksdb/user_defined_index.h:123:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?", "./include/rocksdb/user_defined_index.h:93:30: error: 'ScanOptions' does not name a type; did you mean 'DBOptions'?", "./include/rocksdb/user_defined_index.h:123:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?", "table/block_based/user_defined_index_wrapper.h:182:39: error: cannot convert 'const rocksdb::ScanOptions*' to 'const int*'", "table/block_based/user_defined_index_wrapper.h:223:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "rocksdb/user_defined_index.h:93:30: error: 'ScanOptions' does not name a type; did you mean 'DBOptions'?", "rocksdb/user_defined_index.h:123:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?"], "error_detail": "table/block_based/user_defined_index_wrapper.h:182:39: error: cannot convert 'const rocksdb::ScanOptions*' to 'const int*'\n  182 |     udi_iter_->Prepare(scan_opts->data(), scan_opts->size());\n      |                        ~~~~~~~~~~~~~~~^~\n      |                                       |\n      |                                       const rocksdb::ScanOptions*", "time": 8.25011134147644, "evaluation_mode": "full"}, "timestamp": "2025-08-20 19:57:32"}
{"instance_index": 33, "error_index": 1, "error_result": {"is_successful": false, "is_exact_match": false, "is_valid": false, "error_line": "/__w/rocksdb/rocksdb/include/rocksdb/env.h:851:21: error: 'AccessPattern' has not been declared", "patches": [{"error_line": "/__w/rocksdb/rocksdb/include/rocksdb/env.h:851:21: error: 'AccessPattern' has not been declared", "file_path": "/__w/rocksdb/rocksdb/include/rocksdb/env.h", "start_line": 851, "end_line": 851, "original_code": "  virtual void Hint(AccessPattern /*pattern*/) {}", "fixed_code": "  virtual void Hint(Env::AccessPattern /*pattern*/) {}", "confidence": 0.5, "explanation": ""}], "errors_before": ["/tmp/rocksdb_repo_temp_33_wpwjevl9/include/rocksdb/env.h:851:21: error: 'AccessPattern' has not been declared", "/tmp/rocksdb_repo_temp_33_wpwjevl9/include/rocksdb/env.h:1745:13: error: 'AccessPattern' has not been declared"], "errors_after": ["/tmp/rocksdb_repo_temp_33_wpwjevl9/include/rocksdb/env.h:1745:13: error: 'AccessPattern' has not been declared", "/tmp/rocksdb_repo_temp_33_wpwjevl9/include/rocksdb/env.h:1745:8: error: 'void rocksdb::RandomAccessFileWrapper::Hint(int)' marked 'override', but does not override", "/tmp/rocksdb_repo_temp_33_wpwjevl9/include/rocksdb/env.h:1745:61: error: invalid conversion from 'int' to 'rocksdb::Env::AccessPattern' [-fpermissive]"], "error_detail": "In file included from /__w/rocksdb/rocksdb/include/rocksdb/options.h:26,\n/__w/rocksdb/rocksdb/include/rocksdb/env.h:851:21: error: 'AccessPattern' has not been declared\n  851 |   virtual void Hint(AccessPattern /*pattern*/) {}\n      |                     ^~~~~~~~~~~~~", "time": 5.291898250579834, "evaluation_mode": "full"}, "timestamp": "2025-08-20 19:58:21"}
{"instance_index": 34, "error_index": 1, "error_result": {"is_successful": false, "is_exact_match": false, "is_valid": false, "error_line": "./include/rocksdb/env.h:851:21: error: 'AccessPattern' has not been declared", "patches": [{"error_line": "./include/rocksdb/env.h:851:21: error: 'AccessPattern' has not been declared", "file_path": "include/rocksdb/file_system.h", "start_line": 33, "end_line": 33, "original_code": "#include \"rocksdb/env.h\"", "fixed_code": "#include \"rocksdb/env.h\"\nusing AccessPattern = ROCKSDB_NAMESPACE::Env::AccessPattern;", "confidence": 0.5, "explanation": ""}], "errors_before": ["./include/rocksdb/env.h:851:21: error: 'AccessPattern' has not been declared", "./include/rocksdb/env.h:1745:13: error: 'AccessPattern' has not been declared", "db/blob/blob_file_reader.cc:127:36: error: 'kRandom' is not a member of 'rocksdb::FSRandomAccessFile'"], "errors_after": ["./include/rocksdb/env.h:851:21: error: 'AccessPattern' has not been declared", "./include/rocksdb/env.h:1745:13: error: 'AccessPattern' has not been declared", "db/blob/blob_file_reader.cc:127:36: error: 'kRandom' is not a member of 'rocksdb::FSRandomAccessFile'"], "error_detail": "In file included from ./include/rocksdb/options.h:26,\n./include/rocksdb/env.h:851:21: error: 'AccessPattern' has not been declared\n  851 |   virtual void Hint(AccessPattern /*pattern*/) {}\n      |                     ^~~~~~~~~~~~~", "time": 9.089815139770508, "evaluation_mode": "full"}, "timestamp": "2025-08-20 20:03:19"}
{"instance_index": 31, "error_index": 1, "error_result": {"is_successful": false, "is_exact_match": false, "is_valid": false, "error_line": "/__w/rocksdb/rocksdb/db/blob/blob_file_reader.cc:127:36: error: 'kRandom' is not a member of 'rocksdb::FSRandomAccessFile'", "patches": [{"error_line": "/__w/rocksdb/rocksdb/db/blob/blob_file_reader.cc:127:36: error: 'kRandom' is not a member of 'rocksdb::FSRandomAccessFile'", "file_path": "include/rocksdb/file_system.h", "start_line": 914, "end_line": 1054, "original_code": "class FSRandomAccessFile {\n public:\n  FSRandomAccessFile() {}\n\n  virtual ~FSRandomAccessFile() {}\n\n  // Read up to \"n\" bytes from the file starting at \"offset\".\n  // \"scratch[0..n-1]\" may be written by this routine.  Sets \"*result\"\n  // to the data that was read (including if fewer than \"n\" bytes were\n  // successfully read).  May set \"*result\" to point at data in\n  // \"scratch[0..n-1]\", so \"scratch[0..n-1]\" must be live when\n  // \"*result\" is used.  If an error was encountered, returns a non-OK\n  // status.\n  //\n  // After call, result->size() < n only if end of file has been\n  // reached (or non-OK status). Read might fail if called again after\n  // first result->size() < n.\n  //\n  // Safe for concurrent use by multiple threads.\n  // If Direct I/O enabled, offset, n, and scratch should be aligned properly.\n  virtual IOStatus Read(uint64_t offset, size_t n, const IOOptions& options,\n                        Slice* result, char* scratch,\n                        IODebugContext* dbg) const = 0;\n\n  // Readahead the file starting from offset by n bytes for caching.\n  // If it's not implemented (default: `NotSupported`), RocksDB will create\n  // internal prefetch buffer to improve read performance.\n  virtual IOStatus Prefetch(uint64_t /*offset*/, size_t /*n*/,\n                            const IOOptions& /*options*/,\n                            IODebugContext* /*dbg*/) {\n    return IOStatus::NotSupported(\"Prefetch\");\n  }\n\n  // Read a bunch of blocks as described by reqs. The blocks can\n  // optionally be read in parallel. This is a synchronous call, i.e it\n  // should return after all reads have completed. The reads will be\n  // non-overlapping but can be in any order. If the function return Status\n  // is not ok, status of individual requests will be ignored and return\n  // status will be assumed for all read requests. The function return status\n  // is only meant for errors that occur before processing individual read\n  // requests.\n  virtual IOStatus MultiRead(FSReadRequest* reqs, size_t num_reqs,\n                             const IOOptions& options, IODebugContext* dbg) {\n    assert(reqs != nullptr);\n    for (size_t i = 0; i < num_reqs; ++i) {\n      FSReadRequest& req = reqs[i];\n      req.status =\n          Read(req.offset, req.len, options, &req.result, req.scratch, dbg);\n    }\n    return IOStatus::OK();\n  }\n\n  // Tries to get an unique ID for this file that will be the same each time\n  // the file is opened (and will stay the same while the file is open).\n  // Furthermore, it tries to make this ID at most \"max_size\" bytes. If such an\n  // ID can be created this function returns the length of the ID and places it\n  // in \"id\"; otherwise, this function returns 0, in which case \"id\"\n  // may not have been modified.\n  //\n  // This function guarantees, for IDs from a given environment, two unique ids\n  // cannot be made equal to each other by adding arbitrary bytes to one of\n  // them. That is, no unique ID is the prefix of another.\n  //\n  // This function guarantees that the returned ID will not be interpretable as\n  // a single varint.\n  //\n  // Note: these IDs are only valid for the duration of the process.\n  virtual size_t GetUniqueId(char* /*id*/, size_t /*max_size*/) const {\n    return 0;  // Default implementation to prevent issues with backwards\n               // compatibility.\n  }\n\n  virtual void Hint(AccessPattern /*pattern*/) {}\n\n  // Indicates the upper layers if the current RandomAccessFile implementation\n  // uses direct IO.\n  virtual bool use_direct_io() const { return false; }\n\n  // Use the returned alignment value to allocate\n  // aligned buffer for Direct I/O\n  virtual size_t GetRequiredBufferAlignment() const { return kDefaultPageSize; }\n\n  // Remove any kind of caching of data from the offset to offset+length\n  // of this file. If the length is 0, then it refers to the end of file.\n  // If the system is not caching the file contents, then this is a noop.\n  virtual IOStatus InvalidateCache(size_t /*offset*/, size_t /*length*/) {\n    return IOStatus::NotSupported(\"InvalidateCache not supported.\");\n  }\n\n  // This API reads the requested data in FSReadRequest asynchronously. This is\n  // a asynchronous call, i.e it should return after submitting the request.\n  //\n  // When the read request is completed, callback function specified in cb\n  // should be called with arguments cb_arg and the result populated in\n  // FSReadRequest with result and status fileds updated by FileSystem.\n  // cb_arg should be used by the callback to track the original request\n  // submitted.\n  //\n  // This API should also populate io_handle which should be used by\n  // underlying FileSystem to store the context in order to distinguish the read\n  // requests at their side and provide the custom deletion function in del_fn.\n  // RocksDB guarantees that the del_fn for io_handle will be called after\n  // receiving the callback. Furthermore, RocksDB guarantees that if it calls\n  // the Poll API for this io_handle, del_fn will be called after the Poll\n  // returns. RocksDB is responsible for managing the lifetime of io_handle.\n  //\n  // req contains the request offset and size passed as input parameter of read\n  // request and result and status fields are output parameter set by underlying\n  // FileSystem. The data should always be read into scratch field.\n  //\n  // How to enable:\n  // In order to enable ReadAsync, FS needs to override SupportedOps() API and\n  // set FSSupportedOps::kAsyncIO in SupportedOps() as:\n  //  {\n  //    supported_ops |= (1 << FSSupportedOps::kAsyncIO);\n  //  }\n  //\n  // Note: If FS supports ReadAsync API, it should also override Poll and\n  // AbortIO API.\n  //\n  // Default implementation is to read the data synchronously.\n  virtual IOStatus ReadAsync(FSReadRequest& req, const IOOptions& opts,\n                             std::function<void(FSReadRequest&, void*)> cb,\n                             void* cb_arg, void** /*io_handle*/,\n                             IOHandleDeleter* /*del_fn*/, IODebugContext* dbg) {\n    req.status =\n        Read(req.offset, req.len, opts, &(req.result), req.scratch, dbg);\n    cb(req, cb_arg);\n    return IOStatus::OK();\n  }\n\n  // EXPERIMENTAL\n  // When available, returns the actual temperature for the file. This is\n  // useful in case some outside process moves a file from one tier to another,\n  // though the temperature is generally expected not to change while a file is\n  // open.\n  virtual Temperature GetTemperature() const { return Temperature::kUnknown; }\n\n  // If you're adding methods here, remember to add them to\n  // RandomAccessFileWrapper too.\n};", "fixed_code": "class FSRandomAccessFile {\n public:\n  enum AccessPattern { kNormal, kRandom, kSequential, kWillNeed, kDontNeed };\n\n  FSRandomAccessFile() {}\n\n  virtual ~FSRandomAccessFile() {}\n\n  // Read up to \"n\" bytes from the file starting at \"offset\".\n  // \"scratch[0..n-1]\" may be written by this routine.  Sets \"*result\"\n  // to the data that was read (including if fewer than \"n\" bytes were\n  // successfully read).  May set \"*result\" to point at data in\n  // \"scratch[0..n-1]\", so \"scratch[0..n-1]\" must be live when\n  // \"*result\" is used.  If an error was encountered, returns a non-OK\n  // status.\n  //\n  // After call, result->size() < n only if end of file has been\n  // reached (or non-OK status). Read might fail if called again after\n  // first result->size() < n.\n  //\n  // Safe for concurrent use by multiple threads.\n  // If Direct I/O enabled, offset, n, and scratch should be aligned properly.\n  virtual IOStatus Read(uint64_t offset, size_t n, const IOOptions& options,\n                        Slice* result, char* scratch,\n                        IODebugContext* dbg) const = 0;\n\n  // Readahead the file starting from offset by n bytes for caching.\n  // If it's not implemented (default: `NotSupported`), RocksDB will create\n  // internal prefetch buffer to improve read performance.\n  virtual IOStatus Prefetch(uint64_t /*offset*/, size_t /*n*/,\n                            const IOOptions& /*options*/,\n                            IODebugContext* /*dbg*/) {\n    return IOStatus::NotSupported(\"Prefetch\");\n  }\n\n  // Read a bunch of blocks as described by reqs. The blocks can\n  // optionally be read in parallel. This is a synchronous call, i.e it\n  // should return after all reads have completed. The reads will be\n  // non-overlapping but can be in any order. If the function return Status\n  // is not ok, status of individual requests will be ignored and return\n  // status will be assumed for all read requests. The function return status\n  // is only meant for errors that occur before processing individual read\n  // requests.\n  virtual IOStatus MultiRead(FSReadRequest* reqs, size_t num_reqs,\n                             const IOOptions& options, IODebugContext* dbg) {\n    assert(reqs != nullptr);\n    for (size_t i = 0; i < num_reqs; ++i) {\n      FSReadRequest& req = reqs[i];\n      req.status =\n          Read(req.offset, req.len, options, &req.result, req.scratch, dbg);\n    }\n    return IOStatus::OK();\n  }\n\n  // Tries to get an unique ID for this file that will be the same each time\n  // the file is opened (and will stay the same while the file is open).\n  // Furthermore, it tries to make this ID at most \"max_size\" bytes. If such an\n  // ID can be created this function returns the length of the ID and places it\n  // in \"id\"; otherwise, this function returns 0, in which case \"id\"\n  // may not have been modified.\n  //\n  // This function guarantees, for IDs from a given environment, two unique ids\n  // cannot be made equal to each other by adding arbitrary bytes to one of\n  // them. That is, no unique ID is the prefix of another.\n  //\n  // This function guarantees that the returned ID will not be interpretable as\n  // a single varint.\n  //\n  // Note: these IDs are only valid for the duration of the process.\n  virtual size_t GetUniqueId(char* /*id*/, size_t /*max_size*/) const {\n    return 0;  // Default implementation to prevent issues with backwards\n               // compatibility.\n  }\n\n  virtual void Hint(AccessPattern /*pattern*/) {}\n\n  // Indicates the upper layers if the current RandomAccessFile implementation\n  // uses direct IO.\n  virtual bool use_direct_io() const { return false; }\n\n  // Use the returned alignment value to allocate\n  // aligned buffer for Direct I/O\n  virtual size_t GetRequiredBufferAlignment() const { return kDefaultPageSize; }\n\n  // Remove any kind of caching of data from the offset to offset+length\n  // of this file. If the length is 0, then it refers to the end of file.\n  // If the system is not caching the file contents, then this is a noop.\n  virtual IOStatus InvalidateCache(size_t /*offset*/, size_t /*length*/) {\n    return IOStatus::NotSupported(\"InvalidateCache not supported.\");\n  }\n\n  // This API reads the requested data in FSReadRequest asynchronously. This is\n  // a asynchronous call, i.e it should return after submitting the request.\n  //\n  // When the read request is completed, callback function specified in cb\n  // should be called with arguments cb_arg and the result populated in\n  // FSReadRequest with result and status fileds updated by FileSystem.\n  // cb_arg should be used by the callback to track the original request\n  // submitted.\n  //\n  // This API should also populate io_handle which should be used by\n  // underlying FileSystem to store the context in order to distinguish the read\n  // requests at their side and provide the custom deletion function in del_fn.\n  // RocksDB guarantees that the del_fn for io_handle will be called after\n  // receiving the callback. Furthermore, RocksDB guarantees that if it calls\n  // the Poll API for this io_handle, del_fn will be called after the Poll\n  // returns. RocksDB is responsible for managing the lifetime of io_handle.\n  //\n  // req contains the request offset and size passed as input parameter of read\n  // request and result and status fields are output parameter set by underlying\n  // FileSystem. The data should always be read into scratch field.\n  //\n  // How to enable:\n  // In order to enable ReadAsync, FS needs to override SupportedOps() API and\n  // set FSSupportedOps::kAsyncIO in SupportedOps() as:\n  //  {\n  //    supported_ops |= (1 << FSSupportedOps::kAsyncIO);\n  //  }\n  //\n  // Note: If FS supports ReadAsync API, it should also override Poll and\n  // AbortIO API.\n  //\n  // Default implementation is to read the data synchronously.\n  virtual IOStatus ReadAsync(FSReadRequest& req, const IOOptions& opts,\n                             std::function<void(FSReadRequest&, void*)> cb,\n                             void* cb_arg, void** /*io_handle*/,\n                             IOHandleDeleter* /*del_fn*/, IODebugContext* dbg) {\n    req.status =\n        Read(req.offset, req.len, opts, &(req.result), req.scratch, dbg);\n    cb(req, cb_arg);\n    return IOStatus::OK();\n  }\n\n  // EXPERIMENTAL\n  // When available, returns the actual temperature for the file. This is\n  // useful in case some outside process moves a file from one tier to another,\n  // though the temperature is generally expected not to change while a file is\n  // open.\n  virtual Temperature GetTemperature() const { return Temperature::kUnknown; }\n\n  // If you're adding methods here, remember to add them to\n  // RandomAccessFileWrapper too.\n};", "confidence": 0.5, "explanation": ""}], "errors_before": ["/tmp/rocksdb_repo_temp_31_am1yiyfn/db/blob/blob_file_reader.cc:127:36: error: 'kRandom' is not a member of 'rocksdb::FSRandomAccessFile'"], "errors_after": ["/tmp/rocksdb_repo_temp_31_am1yiyfn/env/env.cc:180:38: error: 'AccessPattern' is not a member of 'rocksdb::RandomAccessFile'"], "error_detail": "/__w/rocksdb/rocksdb/db/blob/blob_file_reader.cc: In static member function 'static rocksdb::Status rocksdb::BlobFileReader::OpenFile(const rocksdb::ImmutableOptions&, const rocksdb::FileOptions&, rocksdb::HistogramImpl*, uint64_t, const std::shared_ptr<rocksdb::IOTracer>&, uint64_t*, std::unique_ptr<rocksdb::RandomAccessFileReader>*)':\n/__w/rocksdb/rocksdb/db/blob/blob_file_reader.cc:127:36: error: 'kRandom' is not a member of 'rocksdb::FSRandomAccessFile'\n  127 |     file->Hint(FSRandomAccessFile::kRandom);\n      |                                    ^~~~~~~", "time": 60.42486572265625, "evaluation_mode": "full"}, "timestamp": "2025-08-20 20:04:26"}
{"instance_index": 32, "error_index": 1, "error_result": {"is_successful": false, "is_exact_match": false, "is_valid": false, "error_line": "db/blob/blob_file_reader.cc:127:36: error: no member named 'kRandom' in 'rocksdb::FSRandomAccessFile'", "patches": [{"error_line": "db/blob/blob_file_reader.cc:127:36: error: no member named 'kRandom' in 'rocksdb::FSRandomAccessFile'", "file_path": "include/rocksdb/file_system.h", "start_line": 914, "end_line": 1054, "original_code": "class FSRandomAccessFile {\n  public:\n   FSRandomAccessFile() {}\n\n   virtual ~FSRandomAccessFile() {}\n\n   // Read up to \"n\" bytes from the file starting at \"offset\".\n   // \"scratch[0..n-1]\" may be written by this routine.  Sets \"*result\"\n   // to the data that was read (including if fewer than \"n\" bytes were\n   // successfully read).  May set \"*result\" to point at data in\n   // \"scratch[0..n-1]\", so \"scratch[0..n-1]\" must be live when\n   // \"*result\" is used.  If an error was encountered, returns a non-OK\n   // status.\n   //\n   // After call, result->size() < n only if end of file has been\n   // reached (or non-OK status). Read might fail if called again after\n   // first result->size() < n.\n   //\n   // Safe for concurrent use by multiple threads.\n   // If Direct I/O enabled, offset, n, and scratch should be aligned properly.\n   virtual IOStatus Read(uint64_t offset, size_t n, const IOOptions& options,\n                         Slice* result, char* scratch,\n                         IODebugContext* dbg) const = 0;\n\n   // Readahead the file starting from offset by n bytes for caching.\n   // If it's not implemented (default: `NotSupported`), RocksDB will create\n   // internal prefetch buffer to improve read performance.\n   virtual IOStatus Prefetch(uint64_t /*offset*/, size_t /*n*/,\n                             const IOOptions& /*options*/,\n                             IODebugContext* /*dbg*/) {\n     return IOStatus::NotSupported(\"Prefetch\");\n   }\n\n   // Read a bunch of blocks as described by reqs. The blocks can\n   // optionally be read in parallel. This is a synchronous call, i.e it\n   // should return after all reads have completed. The reads will be\n   // non-overlapping but can be in any order. If the function return Status\n   // is not ok, status of individual requests will be ignored and return\n   // status will be assumed for all read requests. The function return status\n   // is only meant for errors that occur before processing individual read\n   // requests.\n   virtual IOStatus MultiRead(FSReadRequest* reqs, size_t num_reqs,\n                              const IOOptions& options, IODebugContext* dbg) {\n     assert(reqs != nullptr);\n     for (size_t i = 0; i < num_reqs; ++i) {\n       FSReadRequest& req = reqs[i];\n       req.status =\n           Read(req.offset, req.len, options, &req.result, req.scratch, dbg);\n     }\n     return IOStatus::OK();\n   }\n\n   // Tries to get an unique ID for this file that will be the same each time\n   // the file is opened (and will stay the same while the file is open).\n   // Furthermore, it tries to make this ID at most \"max_size\" bytes. If such an\n   // ID can be created this function returns the length of the ID and places it\n   // in \"id\"; otherwise, this function returns 0, in which case \"id\"\n   // may not have been modified.\n   //\n   // This function guarantees, for IDs from a given environment, two unique ids\n   // cannot be made equal to each other by adding arbitrary bytes to one of\n   // them. That is, no unique ID is the prefix of another.\n   //\n   // This function guarantees that the returned ID will not be interpretable as\n   // a single varint.\n   //\n   // Note: these IDs are only valid for the duration of the process.\n   virtual size_t GetUniqueId(char* /*id*/, size_t /*max_size*/) const {\n     return 0;  // Default implementation to prevent issues with backwards\n                // compatibility.\n   }\n\n   virtual void Hint(AccessPattern /*pattern*/) {}\n\n   // Indicates the upper layers if the current RandomAccessFile implementation\n   // uses direct IO.\n   virtual bool use_direct_io() const { return false; }\n\n   // Use the returned alignment value to allocate\n   // aligned buffer for Direct I/O\n   virtual size_t GetRequiredBufferAlignment() const { return kDefaultPageSize; }\n\n   // Remove any kind of caching of data from the offset to offset+length\n   // of this file. If the length is 0, then it refers to the end of file.\n   // If the system is not caching the file contents, then this is a noop.\n   virtual IOStatus InvalidateCache(size_t /*offset*/, size_t /*length*/) {\n     return IOStatus::NotSupported(\"InvalidateCache not supported.\");\n   }\n\n   // This API reads the requested data in FSReadRequest asynchronously. This is\n   // a asynchronous call, i.e it should return after submitting the request.\n   //\n   // When the read request is completed, callback function specified in cb\n   // should be called with arguments cb_arg and the result populated in\n   // FSReadRequest with result and status fileds updated by FileSystem.\n   // cb_arg should be used by the callback to track the original request\n   // submitted.\n   //\n   // This API should also populate io_handle which should be used by\n   // underlying FileSystem to store the context in order to distinguish the read\n   // requests at their side and provide the custom deletion function in del_fn.\n   // RocksDB guarantees that the del_fn for io_handle will be called after\n   // receiving the callback. Furthermore, RocksDB guarantees that if it calls\n   // the Poll API for this io_handle, del_fn will be called after the Poll\n   // returns. RocksDB is responsible for managing the lifetime of io_handle.\n   //\n   // req contains the request offset and size passed as input parameter of read\n   // request and result and status fields are output parameter set by underlying\n   // FileSystem. The data should always be read into scratch field.\n   //\n   // How to enable:\n   // In order to enable ReadAsync, FS needs to override SupportedOps() API and\n   // set FSSupportedOps::kAsyncIO in SupportedOps() as:\n   //  {\n   //    supported_ops |= (1 << FSSupportedOps::kAsyncIO);\n   //  }\n   //\n   // Note: If FS supports ReadAsync API, it should also override Poll and\n   // AbortIO API.\n   //\n   // Default implementation is to read the data synchronously.\n   virtual IOStatus ReadAsync(FSReadRequest& req, const IOOptions& opts,\n                              std::function<void(FSReadRequest&, void*)> cb,\n                              void* cb_arg, void** /*io_handle*/,\n                              IOHandleDeleter* /*del_fn*/, IODebugContext* dbg) {\n     req.status =\n         Read(req.offset, req.len, opts, &(req.result), req.scratch, dbg);\n     cb(req, cb_arg);\n     return IOStatus::OK();\n   }\n\n   // EXPERIMENTAL\n   // When available, returns the actual temperature for the file. This is\n   // useful in case some outside process moves a file from one tier to another,\n   // though the temperature is generally expected not to change while a file is\n   // open.\n   virtual Temperature GetTemperature() const { return Temperature::kUnknown; }\n\n   // If you're adding methods here, remember to add them to\n   // RandomAccessFileWrapper too.\n};", "fixed_code": "class FSRandomAccessFile {\n  public:\n   FSRandomAccessFile() {}\n\n   virtual ~FSRandomAccessFile() {}\n\n   // Access pattern hints for file reading\n   enum AccessPattern {\n     kNormal,\n     kRandom,\n     kSequential,\n     kWillNeed,\n     kDontNeed\n   };\n\n   // Read up to \"n\" bytes from the file starting at \"offset\".\n   // \"scratch[0..n-1]\" may be written by this routine.  Sets \"*result\"\n   // to the data that was read (including if fewer than \"n\" bytes were\n   // successfully read).  May set \"*result\" to point at data in\n   // \"scratch[0..n-1]\", so \"scratch[0..n-1]\" must be live when\n   // \"*result\" is used.  If an error was encountered, returns a non-OK\n   // status.\n   //\n   // After call, result->size() < n only if end of file has been\n   // reached (or non-OK status). Read might fail if called again after\n   // first result->size() < n.\n   //\n   // Safe for concurrent use by multiple threads.\n   // If Direct I/O enabled, offset, n, and scratch should be aligned properly.\n   virtual IOStatus Read(uint64_t offset, size_t n, const IOOptions& options,\n                         Slice* result, char* scratch,\n                         IODebugContext* dbg) const = 0;\n\n   // Readahead the file starting from offset by n bytes for caching.\n   // If it's not implemented (default: `NotSupported`), RocksDB will create\n   // internal prefetch buffer to improve read performance.\n   virtual IOStatus Prefetch(uint64_t /*offset*/, size_t /*n*/,\n                             const IOOptions& /*options*/,\n                             IODebugContext* /*dbg*/) {\n     return IOStatus::NotSupported(\"Prefetch\");\n   }\n\n   // Read a bunch of blocks as described by reqs. The blocks can\n   // optionally be read in parallel. This is a synchronous call, i.e it\n   // should return after all reads have completed. The reads will be\n   // non-overlapping but can be in any order. If the function return Status\n   // is not ok, status of individual requests will be ignored and return\n   // status will be assumed for all read requests. The function return status\n   // is only meant for errors that occur before processing individual read\n   // requests.\n   virtual IOStatus MultiRead(FSReadRequest* reqs, size_t num_reqs,\n                              const IOOptions& options, IODebugContext* dbg) {\n     assert(reqs != nullptr);\n     for (size_t i = 0; i < num_reqs; ++i) {\n       FSReadRequest& req = reqs[i];\n       req.status =\n           Read(req.offset, req.len, options, &req.result, req.scratch, dbg);\n     }\n     return IOStatus::OK();\n   }\n\n   // Tries to get an unique ID for this file that will be the same each time\n   // the file is opened (and will stay the same while the file is open).\n   // Furthermore, it tries to make this ID at most \"max_size\" bytes. If such an\n   // ID can be created this function returns the length of the ID and places it\n   // in \"id\"; otherwise, this function returns 0, in which case \"id\"\n   // may not have been modified.\n   //\n   // This function guarantees, for IDs from a given environment, two unique ids\n   // cannot be made equal to each other by adding arbitrary bytes to one of\n   // them. That is, no unique ID is the prefix of another.\n   //\n   // This function guarantees that the returned ID will not be interpretable as\n   // a single varint.\n   //\n   // Note: these IDs are only valid for the duration of the process.\n   virtual size_t GetUniqueId(char* /*id*/, size_t /*max_size*/) const {\n     return 0;  // Default implementation to prevent issues with backwards\n                // compatibility.\n   }\n\n   virtual void Hint(AccessPattern /*pattern*/) {}\n\n   // Indicates the upper layers if the current RandomAccessFile implementation\n   // uses direct IO.\n   virtual bool use_direct_io() const { return false; }\n\n   // Use the returned alignment value to allocate\n   // aligned buffer for Direct I/O\n   virtual size_t GetRequiredBufferAlignment() const { return kDefaultPageSize; }\n\n   // Remove any kind of caching of data from the offset to offset+length\n   // of this file. If the length is 0, then it refers to the end of file.\n   // If the system is not caching the file contents, then this is a noop.\n   virtual IOStatus InvalidateCache(size_t /*offset*/, size_t /*length*/) {\n     return IOStatus::NotSupported(\"InvalidateCache not supported.\");\n   }\n\n   // This API reads the requested data in FSReadRequest asynchronously. This is\n   // a asynchronous call, i.e it should return after submitting the request.\n   //\n   // When the read request is completed, callback function specified in cb\n   // should be called with arguments cb_arg and the result populated in\n   // FSReadRequest with result and status fileds updated by FileSystem.\n   // cb_arg should be used by the callback to track the original request\n   // submitted.\n   //\n   // This API should also populate io_handle which should be used by\n   // underlying FileSystem to store the context in order to distinguish the read\n   // requests at their side and provide the custom deletion function in del_fn.\n   // RocksDB guarantees that the del_fn for io_handle will be called after\n   // receiving the callback. Furthermore, RocksDB guarantees that if it calls\n   // the Poll API for this io_handle, del_fn will be called after the Poll\n   // returns. RocksDB is responsible for managing the lifetime of io_handle.\n   //\n   // req contains the request offset and size passed as input parameter of read\n   // request and result and status fields are output parameter set by underlying\n   // FileSystem. The data should always be read into scratch field.\n   //\n   // How to enable:\n   // In order to enable ReadAsync, FS needs to override SupportedOps() API and\n   // set FSSupportedOps::kAsyncIO in SupportedOps() as:\n   //  {\n   //    supported_ops |= (1 << FSSupportedOps::kAsyncIO);\n   //  }\n   //\n   // Note: If FS supports ReadAsync API, it should also override Poll and\n   // AbortIO API.\n   //\n   // Default implementation is to read the data synchronously.\n   virtual IOStatus ReadAsync(FSReadRequest& req, const IOOptions& opts,\n                              std::function<void(FSReadRequest&, void*)> cb,\n                              void* cb_arg, void** /*io_handle*/,\n                              IOHandleDeleter* /*del_fn*/, IODebugContext* dbg) {\n     req.status =\n         Read(req.offset, req.len, opts, &(req.result), req.scratch, dbg);\n     cb(req, cb_arg);\n     return IOStatus::OK();\n   }\n\n   // EXPERIMENTAL\n   // When available, returns the actual temperature for the file. This is\n   // useful in case some outside process moves a file from one tier to another,\n   // though the temperature is generally expected not to change while a file is\n   // open.\n   virtual Temperature GetTemperature() const { return Temperature::kUnknown; }\n\n   // If you're adding methods here, remember to add them to\n   // RandomAccessFileWrapper too.\n};", "confidence": 0.5, "explanation": ""}], "errors_before": ["db/blob/blob_file_reader.cc:127:36: error: no member named 'kRandom' in 'rocksdb::FSRandomAccessFile'"], "errors_after": ["env/env.cc:180:38: error: no member named 'AccessPattern' in 'rocksdb::RandomAccessFile'"], "error_detail": "db/blob/blob_file_reader.cc:127:36: error: no member named 'kRandom' in 'rocksdb::FSRandomAccessFile'\n    file->Hint(FSRandomAccessFile::kRandom);\n               ~~~~~~~~~~~~~~~~~~~~^\nmkdir -p db/compaction && clang++  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Wshift-sign-overflow -Wambiguous-reversed-operator -Wimplicit-fallthrough -Wreinterpret-base-class -Wundefined-reinterpret-cast -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -Wshorten-64-to-32 -DHAVE_UINT128_EXTENSION  -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c db/compaction/compaction.cc -o db/compaction/compaction.o\nmkdir -p db/compaction && clang++  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Wshift-sign-overflow -Wambiguous-reversed-operator -Wimplicit-fallthrough -Wreinterpret-base-class -Wundefined-reinterpret-cast -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -Wshorten-64-to-32 -DHAVE_UINT128_EXTENSION  -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c db/compaction/compaction_iterator.cc -o db/compaction/compaction_iterator.o\nmkdir -p db/compaction && clang++  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Wshift-sign-overflow -Wambiguous-reversed-operator -Wimplicit-fallthrough -Wreinterpret-base-class -Wundefined-reinterpret-cast -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -Wshorten-64-to-32 -DHAVE_UINT128_EXTENSION  -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c db/compaction/compaction_job.cc -o db/compaction/compaction_job.o", "time": 75.44421243667603, "evaluation_mode": "full"}, "timestamp": "2025-08-20 20:05:18"}
{"instance_index": 34, "error_index": 3, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "db/blob/blob_file_reader.cc:127:36: error: 'kRandom' is not a member of 'rocksdb::FSRandomAccessFile'", "patches": [{"error_line": "db/blob/blob_file_reader.cc:127:36: error: 'kRandom' is not a member of 'rocksdb::FSRandomAccessFile'", "file_path": "include/rocksdb/file_system.h", "start_line": 915, "end_line": 1055, "original_code": "class FSRandomAccessFile {\n public:\n  FSRandomAccessFile() {}\n\n  virtual ~FSRandomAccessFile() {}\n\n  // Read up to \"n\" bytes from the file starting at \"offset\".\n  // \"scratch[0..n-1]\" may be written by this routine.  Sets \"*result\"\n  // to the data that was read (including if fewer than \"n\" bytes were\n  // successfully read).  May set \"*result\" to point at data in\n  // \"scratch[0..n-1]\", so \"scratch[0..n-1]\" must be live when\n  // \"*result\" is used.  If an error was encountered, returns a non-OK\n  // status.\n  //\n  // After call, result->size() < n only if end of file has been\n  // reached (or non-OK status). Read might fail if called again after\n  // first result->size() < n.\n  //\n  // Safe for concurrent use by multiple threads.\n  // If Direct I/O enabled, offset, n, and scratch should be aligned properly.\n  virtual IOStatus Read(uint64_t offset, size_t n, const IOOptions& options,\n                        Slice* result, char* scratch,\n                        IODebugContext* dbg) const = 0;\n\n  // Readahead the file starting from offset by n bytes for caching.\n  // If it's not implemented (default: `NotSupported`), RocksDB will create\n  // internal prefetch buffer to improve read performance.\n  virtual IOStatus Prefetch(uint64_t /*offset*/, size_t /*n*/,\n                            const IOOptions& /*options*/,\n                            IODebugContext* /*dbg*/) {\n    return IOStatus::NotSupported(\"Prefetch\");\n  }\n\n  // Read a bunch of blocks as described by reqs. The blocks can\n  // optionally be read in parallel. This is a synchronous call, i.e it\n  // should return after all reads have completed. The reads will be\n  // non-overlapping but can be in any order. If the function return Status\n  // is not ok, status of individual requests will be ignored and return\n  // status will be assumed for all read requests. The function return status\n  // is only meant for errors that occur before processing individual read\n  // requests.\n  virtual IOStatus MultiRead(FSReadRequest* reqs, size_t num_reqs,\n                             const IOOptions& options, IODebugContext* dbg) {\n    assert(reqs != nullptr);\n    for (size_t i = 0; i < num_reqs; ++i) {\n      FSReadRequest& req = reqs[i];\n      req.status =\n          Read(req.offset, req.len, options, &req.result, req.scratch, dbg);\n    }\n    return IOStatus::OK();\n  }\n\n  // Tries to get an unique ID for this file that will be the same each time\n  // the file is opened (and will stay the same while the file is open).\n  // Furthermore, it tries to make this ID at most \"max_size\" bytes. If such an\n  // ID can be created this function returns the length of the ID and places it\n  // in \"id\"; otherwise, this function returns 0, in which case \"id\"\n  // may not have been modified.\n  //\n  // This function guarantees, for IDs from a given environment, two unique ids\n  // cannot be made equal to each other by adding arbitrary bytes to one of\n  // them. That is, no unique ID is the prefix of another.\n  //\n  // This function guarantees that the returned ID will not be interpretable as\n  // a single varint.\n  //\n  // Note: these IDs are only valid for the duration of the process.\n  virtual size_t GetUniqueId(char* /*id*/, size_t /*max_size*/) const {\n    return 0;  // Default implementation to prevent issues with backwards\n               // compatibility.\n  }\n\n  virtual void Hint(AccessPattern /*pattern*/) {}\n\n  // Indicates the upper layers if the current RandomAccessFile implementation\n  // uses direct IO.\n  virtual bool use_direct_io() const { return false; }\n\n  // Use the returned alignment value to allocate\n  // aligned buffer for Direct I/O\n  virtual size_t GetRequiredBufferAlignment() const { return kDefaultPageSize; }\n\n  // Remove any kind of caching of data from the offset to offset+length\n  // of this file. If the length is 0, then it refers to the end of file.\n  // If the system is not caching the file contents, then this is a noop.\n  virtual IOStatus InvalidateCache(size_t /*offset*/, size_t /*length*/) {\n    return IOStatus::NotSupported(\"InvalidateCache not supported.\");\n  }\n\n  // This API reads the requested data in FSReadRequest asynchronously. This is\n  // a asynchronous call, i.e it should return after submitting the request.\n  //\n  // When the read request is completed, callback function specified in cb\n  // should be called with arguments cb_arg and the result populated in\n  // FSReadRequest with result and status fileds updated by FileSystem.\n  // cb_arg should be used by the callback to track the original request\n  // submitted.\n  //\n  // This API should also populate io_handle which should be used by\n  // underlying FileSystem to store the context in order to distinguish the read\n  // requests at their side and provide the custom deletion function in del_fn.\n  // RocksDB guarantees that the del_fn for io_handle will be called after\n  // receiving the callback. Furthermore, RocksDB guarantees that if it calls\n  // the Poll API for this io_handle, del_fn will be called after the Poll\n  // returns. RocksDB is responsible for managing the lifetime of io_handle.\n  //\n  // req contains the request offset and size passed as input parameter of read\n  // request and result and status fields are output parameter set by underlying\n  // FileSystem. The data should always be read into scratch field.\n  //\n  // How to enable:\n  // In order to enable ReadAsync, FS needs to override SupportedOps() API and\n  // set FSSupportedOps::kAsyncIO in SupportedOps() as:\n  //  {\n  //    supported_ops |= (1 << FSSupportedOps::kAsyncIO);\n  //  }\n  //\n  // Note: If FS supports ReadAsync API, it should also override Poll and\n  // AbortIO API.\n  //\n  // Default implementation is to read the data synchronously.\n  virtual IOStatus ReadAsync(FSReadRequest& req, const IOOptions& opts,\n                             std::function<void(FSReadRequest&, void*)> cb,\n                             void* cb_arg, void** /*io_handle*/,\n                             IOHandleDeleter* /*del_fn*/, IODebugContext* dbg) {\n    req.status =\n        Read(req.offset, req.len, opts, &(req.result), req.scratch, dbg);\n    cb(req, cb_arg);\n    return IOStatus::OK();\n  }\n\n  // EXPERIMENTAL\n  // When available, returns the actual temperature for the file. This is\n  // useful in case some outside process moves a file from one tier to another,\n  // though the temperature is generally expected not to change while a file is\n  // open.\n  virtual Temperature GetTemperature() const { return Temperature::kUnknown; }\n\n  // If you're adding methods here, remember to add them to\n  // RandomAccessFileWrapper too.\n};", "fixed_code": "class FSRandomAccessFile {\n public:\n  enum AccessPattern { kNormal, kRandom, kSequential, kWillNeed, kDontNeed };\n\n  FSRandomAccessFile() {}\n\n  virtual ~FSRandomAccessFile() {}\n\n  // Read up to \"n\" bytes from the file starting at \"offset\".\n  // \"scratch[0..n-1]\" may be written by this routine.  Sets \"*result\"\n  // to the data that was read (including if fewer than \"n\" bytes were\n  // successfully read).  May set \"*result\" to point at data in\n  // \"scratch[0..n-1]\", so \"scratch[0..n-1]\" must be live when\n  // \"*result\" is used.  If an error was encountered, returns a non-OK\n  // status.\n  //\n  // After call, result->size() < n only if end of file has been\n  // reached (or non-OK status). Read might fail if called again after\n  // first result->size() < n.\n  //\n  // Safe for concurrent use by multiple threads.\n  // If Direct I/O enabled, offset, n, and scratch should be aligned properly.\n  virtual IOStatus Read(uint64_t offset, size_t n, const IOOptions& options,\n                        Slice* result, char* scratch,\n                        IODebugContext* dbg) const = 0;\n\n  // Readahead the file starting from offset by n bytes for caching.\n  // If it's not implemented (default: `NotSupported`), RocksDB will create\n  // internal prefetch buffer to improve read performance.\n  virtual IOStatus Prefetch(uint64_t /*offset*/, size_t /*n*/,\n                            const IOOptions& /*options*/,\n                            IODebugContext* /*dbg*/) {\n    return IOStatus::NotSupported(\"Prefetch\");\n  }\n\n  // Read a bunch of blocks as described by reqs. The blocks can\n  // optionally be read in parallel. This is a synchronous call, i.e it\n  // should return after all reads have completed. The reads will be\n  // non-overlapping but can be in any order. If the function return Status\n  // is not ok, status of individual requests will be ignored and return\n  // status will be assumed for all read requests. The function return status\n  // is only meant for errors that occur before processing individual read\n  // requests.\n  virtual IOStatus MultiRead(FSReadRequest* reqs, size_t num_reqs,\n                             const IOOptions& options, IODebugContext* dbg) {\n    assert(reqs != nullptr);\n    for (size_t i = 0; i < num_reqs; ++i) {\n      FSReadRequest& req = reqs[i];\n      req.status =\n          Read(req.offset, req.len, options, &req.result, req.scratch, dbg);\n    }\n    return IOStatus::OK();\n  }\n\n  // Tries to get an unique ID for this file that will be the same each time\n  // the file is opened (and will stay the same while the file is open).\n  // Furthermore, it tries to make this ID at most \"max_size\" bytes. If such an\n  // ID can be created this function returns the length of the ID and places it\n  // in \"id\"; otherwise, this function returns 0, in which case \"id\"\n  // may not have been modified.\n  //\n  // This function guarantees, for IDs from a given environment, two unique ids\n  // cannot be made equal to each other by adding arbitrary bytes to one of\n  // them. That is, no unique ID is the prefix of another.\n  //\n  // This function guarantees that the returned ID will not be interpretable as\n  // a single varint.\n  //\n  // Note: these IDs are only valid for the duration of the process.\n  virtual size_t GetUniqueId(char* /*id*/, size_t /*max_size*/) const {\n    return 0;  // Default implementation to prevent issues with backwards\n               // compatibility.\n  }\n\n  virtual void Hint(AccessPattern /*pattern*/) {}\n\n  // Indicates the upper layers if the current RandomAccessFile implementation\n  // uses direct IO.\n  virtual bool use_direct_io() const { return false; }\n\n  // Use the returned alignment value to allocate\n  // aligned buffer for Direct I/O\n  virtual size_t GetRequiredBufferAlignment() const { return kDefaultPageSize; }\n\n  // Remove any kind of caching of data from the offset to offset+length\n  // of this file. If the length is 0, then it refers to the end of file.\n  // If the system is not caching the file contents, then this is a noop.\n  virtual IOStatus InvalidateCache(size_t /*offset*/, size_t /*length*/) {\n    return IOStatus::NotSupported(\"InvalidateCache not supported.\");\n  }\n\n  // This API reads the requested data in FSReadRequest asynchronously. This is\n  // a asynchronous call, i.e it should return after submitting the request.\n  //\n  // When the read request is completed, callback function specified in cb\n  // should be called with arguments cb_arg and the result populated in\n  // FSReadRequest with result and status fileds updated by FileSystem.\n  // cb_arg should be used by the callback to track the original request\n  // submitted.\n  //\n  // This API should also populate io_handle which should be used by\n  // underlying FileSystem to store the context in order to distinguish the read\n  // requests at their side and provide the custom deletion function in del_fn.\n  // RocksDB guarantees that the del_fn for io_handle will be called after\n  // receiving the callback. Furthermore, RocksDB guarantees that if it calls\n  // the Poll API for this io_handle, del_fn will be called after the Poll\n  // returns. RocksDB is responsible for managing the lifetime of io_handle.\n  //\n  // req contains the request offset and size passed as input parameter of read\n  // request and result and status fields are output parameter set by underlying\n  // FileSystem. The data should always be read into scratch field.\n  //\n  // How to enable:\n  // In order to enable ReadAsync, FS needs to override SupportedOps() API and\n  // set FSSupportedOps::kAsyncIO in SupportedOps() as:\n  //  {\n  //    supported_ops |= (1 << FSSupportedOps::kAsyncIO);\n  //  }\n  //\n  // Note: If FS supports ReadAsync API, it should also override Poll and\n  // AbortIO API.\n  //\n  // Default implementation is to read the data synchronously.\n  virtual IOStatus ReadAsync(FSReadRequest& req, const IOOptions& opts,\n                             std::function<void(FSReadRequest&, void*)> cb,\n                             void* cb_arg, void** /*io_handle*/,\n                             IOHandleDeleter* /*del_fn*/, IODebugContext* dbg) {\n    req.status =\n        Read(req.offset, req.len, opts, &(req.result), req.scratch, dbg);\n    cb(req, cb_arg);\n    return IOStatus::OK();\n  }\n\n  // EXPERIMENTAL\n  // When available, returns the actual temperature for the file. This is\n  // useful in case some outside process moves a file from one tier to another,\n  // though the temperature is generally expected not to change while a file is\n  // open.\n  virtual Temperature GetTemperature() const { return Temperature::kUnknown; }\n\n  // If you're adding methods here, remember to add them to\n  // RandomAccessFileWrapper too.\n};", "confidence": 0.5, "explanation": ""}], "errors_before": ["./include/rocksdb/env.h:851:21: error: 'AccessPattern' has not been declared", "./include/rocksdb/env.h:1745:13: error: 'AccessPattern' has not been declared", "db/blob/blob_file_reader.cc:127:36: error: 'kRandom' is not a member of 'rocksdb::FSRandomAccessFile'"], "errors_after": ["./include/rocksdb/env.h:851:21: error: 'AccessPattern' has not been declared", "./include/rocksdb/env.h:1745:13: error: 'AccessPattern' has not been declared"], "error_detail": "./include/rocksdb/data_structure.h: In instantiation of 'static constexpr rocksdb::SmallEnumSet<ENUM_TYPE, MAX_ENUMERATOR> rocksdb::SmallEnumSet<ENUM_TYPE, MAX_ENUMERATOR>::All() [with ENUM_TYPE = rocksdb::experimental::KeySegmentsExtractor::KeyCategory; ENUM_TYPE MAX_ENUMERATOR = rocksdb::experimental::KeySegmentsExtractor::kReservedHighCategory]':\n./include/rocksdb/experimental.h:549:67:   required from here\n/usr/include/c++/9/array:94:12: note: 'using StateT = struct std::array<long unsigned int, 1>' {aka 'struct std::array<long unsigned int, 1>'} has no user-provided default constructor\n/usr/include/c++/9/array:110:56: note: and the implicitly-defined constructor does not initialize 'long unsigned int std::array<long unsigned int, 1>::_M_elems [1]'\ndb/blob/blob_file_reader.cc:127:36: error: 'kRandom' is not a member of 'rocksdb::FSRandomAccessFile'\n  127 |     file->Hint(FSRandomAccessFile::kRandom);\n      |                                    ^~~~~~~", "time": 56.22373414039612, "evaluation_mode": "full"}, "timestamp": "2025-08-20 20:06:08"}
{"instance_index": 23, "error_index": 3, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "include/rocksdb/user_defined_index.h:126:53: error: expected class-name before '{' token", "patches": [{"error_line": "include/rocksdb/user_defined_index.h:126:53: error: expected class-name before '{' token", "file_path": "include/rocksdb/user_defined_index.h", "start_line": 8, "end_line": 8, "original_code": "#include <string>", "fixed_code": "#include <string>\n#include \"rocksdb/customizable.h\"", "confidence": 0.5, "explanation": ""}], "errors_before": ["include/rocksdb/user_defined_index.h:88:30: error: 'ScanOptions' does not name a type", "include/rocksdb/user_defined_index.h:118:13: error: 'ReadOptions' does not name a type", "include/rocksdb/user_defined_index.h:126:53: error: expected class-name before '{' token", "./include/rocksdb/user_defined_index.h:88:30: error: 'ScanOptions' does not name a type", "./include/rocksdb/user_defined_index.h:118:13: error: 'ReadOptions' does not name a type", "./include/rocksdb/user_defined_index.h:126:53: error: expected class-name before '{' token", "table/block_based/user_defined_index_wrapper.h:182:39: error: cannot convert 'const rocksdb::ScanOptions*' to 'const int*'", "table/block_based/user_defined_index_wrapper.h:223:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "rocksdb/user_defined_index.h:88:30: error: 'ScanOptions' does not name a type", "rocksdb/user_defined_index.h:118:13: error: 'ReadOptions' does not name a type", "rocksdb/user_defined_index.h:126:53: error: expected class-name before '{' token"], "errors_after": ["include/rocksdb/user_defined_index.h:89:30: error: 'ScanOptions' does not name a type; did you mean 'DBOptions'?", "include/rocksdb/user_defined_index.h:119:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?", "./include/rocksdb/user_defined_index.h:89:30: error: 'ScanOptions' does not name a type; did you mean 'DBOptions'?", "./include/rocksdb/user_defined_index.h:119:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?", "table/block_based/user_defined_index_wrapper.h:182:39: error: cannot convert 'const rocksdb::ScanOptions*' to 'const int*'", "table/block_based/user_defined_index_wrapper.h:223:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "rocksdb/user_defined_index.h:89:30: error: 'ScanOptions' does not name a type; did you mean 'DBOptions'?", "rocksdb/user_defined_index.h:119:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?"], "error_detail": "include/rocksdb/user_defined_index.h:126:53: error: expected class-name before '{' token\n  126 | class UserDefinedIndexFactory : public Customizable {\n      |                                                     ^", "time": 7.875328779220581, "evaluation_mode": "full"}, "timestamp": "2025-08-20 20:07:26"}
{"instance_index": 37, "error_index": 1, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "./include/rocksdb/env.h:851:21: error: unknown type name 'AccessPattern'; did you mean 'Env::AccessPattern''", "patches": [{"error_line": "./include/rocksdb/env.h:851:21: error: unknown type name 'AccessPattern'; did you mean 'Env::AccessPattern''", "file_path": "./include/rocksdb/env.h", "start_line": 851, "end_line": 851, "original_code": "  virtual void Hint(AccessPattern /*pattern*/) {}", "fixed_code": "  virtual void Hint(Env::AccessPattern /*pattern*/) {}", "confidence": 0.5, "explanation": ""}], "errors_before": ["./include/rocksdb/env.h:851:21: error: unknown type name 'AccessPattern'; did you mean 'Env::AccessPattern'?", "./include/rocksdb/env.h:1745:13: error: unknown type name 'AccessPattern'; did you mean 'Env::AccessPattern'?"], "errors_after": ["./include/rocksdb/env.h:1745:13: error: unknown type name 'AccessPattern'; did you mean 'Env::AccessPattern'?"], "error_detail": "In file included from cache/secondary_cache.cc:6:\nIn file included from ./include/rocksdb/secondary_cache.h:12:\nIn file included from ./include/rocksdb/advanced_cache.h:18:\nIn file included from ./include/rocksdb/options.h:26:\n./include/rocksdb/env.h:851:21: error: unknown type name 'AccessPattern'; did you mean 'Env::AccessPattern''\n  virtual void Hint(AccessPattern /*pattern*/) {}\n                    ^~~~~~~~~~~~~\n                    Env::AccessPattern", "time": 8.138768911361694, "evaluation_mode": "full"}, "timestamp": "2025-08-20 20:07:58"}
{"instance_index": 36, "error_index": 1, "error_result": {"is_successful": false, "is_exact_match": false, "is_valid": false, "error_line": "./include/rocksdb/env.h:851:21: error: unknown type name 'AccessPattern'; did you mean 'Env::AccessPattern''", "patches": [{"error_line": "./include/rocksdb/env.h:851:21: error: unknown type name 'AccessPattern'; did you mean 'Env::AccessPattern''", "file_path": "include/rocksdb/file_system.h", "start_line": 986, "end_line": 986, "original_code": "  virtual void Hint(AccessPattern /*pattern*/) {}", "fixed_code": "  virtual void Hint(Env::AccessPattern /*pattern*/) {}", "confidence": 0.5, "explanation": ""}], "errors_before": ["./include/rocksdb/env.h:851:21: error: unknown type name 'AccessPattern'; did you mean 'Env::AccessPattern'?", "./include/rocksdb/env.h:1745:13: error: unknown type name 'AccessPattern'; did you mean 'Env::AccessPattern'?", "./include/rocksdb/env.h./include/rocksdb/env.h:1745:13: error: unknown type name 'AccessPattern'; did you mean 'Env::AccessPattern'?", "virtual void Hint(AccessPattern /*pattern*/) {}./include/rocksdb/env.h:1745:13: error: unknown type name 'AccessPattern'; did you mean 'Env::AccessPattern'?", "db/blob/blob_file_reader.cc:127:36: error: no member named 'kRandom' in 'rocksdb::FSRandomAccessFile'"], "errors_after": ["./include/rocksdb/env.h:851:21: error: unknown type name 'AccessPattern'; did you mean 'Env::AccessPattern'?", "./include/rocksdb/env.h:1745:13: error: unknown type name 'AccessPattern'; did you mean 'Env::AccessPattern'?", "In file included from ./include/rocksdb/env.h:1745:13: error: unknown type name 'AccessPattern'; did you mean 'Env::AccessPattern'?", "^~~~~~~~~~~~~./include/rocksdb/env.h:1745:13: error: unknown type name 'AccessPattern'; did you mean 'Env::AccessPattern'?", "db/blob/blob_file_reader.cc:127:36: error: no member named 'kRandom' in 'rocksdb::FSRandomAccessFile'"], "error_detail": "In file included from cache/cache_key.cc:11:\nIn file included from ./include/rocksdb/advanced_cache.h:18:\nIn file included from ./include/rocksdb/options.h:26:\n./include/rocksdb/env.h:851:21: error: unknown type name 'AccessPattern'; did you mean 'Env::AccessPattern''\n  virtual void Hint(AccessPattern /*pattern*/) {}\n                    ^~~~~~~~~~~~~\n                    Env::AccessPattern", "time": 12.044023752212524, "evaluation_mode": "full"}, "timestamp": "2025-08-20 20:08:10"}
{"instance_index": 38, "error_index": 1, "error_result": {"is_successful": false, "is_exact_match": false, "is_valid": false, "error_line": "./include/rocksdb/env.h:851:21: error: 'AccessPattern' has not been declared", "patches": [{"error_line": "./include/rocksdb/env.h:851:21: error: 'AccessPattern' has not been declared", "file_path": "include/rocksdb/file_system.h", "start_line": 33, "end_line": 33, "original_code": "#include \"rocksdb/env.h\"", "fixed_code": "#include \"rocksdb/env.h\"\nusing EnvAccessPattern = ROCKSDB_NAMESPACE::Env::AccessPattern;", "confidence": 0.5, "explanation": ""}, {"error_line": "./include/rocksdb/env.h:851:21: error: 'AccessPattern' has not been declared", "file_path": "include/rocksdb/file_system.h", "start_line": 54, "end_line": 54, "original_code": "using AccessPattern = Env::AccessPattern;", "fixed_code": "using AccessPattern = EnvAccessPattern;", "confidence": 0.5, "explanation": ""}], "errors_before": ["./include/rocksdb/env.h:851:21: error: 'AccessPattern' has not been declared", "./include/rocksdb/env.h:1745:13: error: 'AccessPattern' has not been declared", "db/blob/blob_file_reader.cc:127:36: error: 'kRandom' is not a member of 'alternative_rocksdb_ns::FSRandomAccessFile'"], "errors_after": ["./include/rocksdb/env.h:851:21: error: 'AccessPattern' has not been declared", "./include/rocksdb/env.h:1745:13: error: 'AccessPattern' has not been declared", "db/blob/blob_file_reader.cc:127:36: error: 'kRandom' is not a member of 'alternative_rocksdb_ns::FSRandomAccessFile'"], "error_detail": "In file included from ./include/rocksdb/options.h:26,\n./include/rocksdb/env.h:851:21: error: 'AccessPattern' has not been declared\n  851 |   virtual void Hint(AccessPattern /*pattern*/) {}\n      |                     ^~~~~~~~~~~~~", "time": 7.043211460113525, "evaluation_mode": "full"}, "timestamp": "2025-08-20 20:09:25"}
{"instance_index": 38, "error_index": 3, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "db/blob/blob_file_reader.cc:127:36: error: 'kRandom' is not a member of 'alternative_rocksdb_ns::FSRandomAccessFile'", "patches": [{"error_line": "db/blob/blob_file_reader.cc:127:36: error: 'kRandom' is not a member of 'alternative_rocksdb_ns::FSRandomAccessFile'", "file_path": "include/rocksdb/file_system.h", "start_line": 915, "end_line": 1055, "original_code": "class FSRandomAccessFile {\n public:\n  FSRandomAccessFile() {}\n\n  virtual ~FSRandomAccessFile() {}\n\n  // Read up to \"n\" bytes from the file starting at \"offset\".\n  // \"scratch[0..n-1]\" may be written by this routine.  Sets \"*result\"\n  // to the data that was read (including if fewer than \"n\" bytes were\n  // successfully read).  May set \"*result\" to point at data in\n  // \"scratch[0..n-1]\", so \"scratch[0..n-1]\" must be live when\n  // \"*result\" is used.  If an error was encountered, returns a non-OK\n  // status.\n  //\n  // After call, result->size() < n only if end of file has been\n  // reached (or non-OK status). Read might fail if called again after\n  // first result->size() < n.\n  //\n  // Safe for concurrent use by multiple threads.\n  // If Direct I/O enabled, offset, n, and scratch should be aligned properly.\n  virtual IOStatus Read(uint64_t offset, size_t n, const IOOptions& options,\n                        Slice* result, char* scratch,\n                        IODebugContext* dbg) const = 0;\n\n  // Readahead the file starting from offset by n bytes for caching.\n  // If it's not implemented (default: `NotSupported`), RocksDB will create\n  // internal prefetch buffer to improve read performance.\n  virtual IOStatus Prefetch(uint64_t /*offset*/, size_t /*n*/,\n                            const IOOptions& /*options*/,\n                            IODebugContext* /*dbg*/) {\n    return IOStatus::NotSupported(\"Prefetch\");\n  }\n\n  // Read a bunch of blocks as described by reqs. The blocks can\n  // optionally be read in parallel. This is a synchronous call, i.e it\n  // should return after all reads have completed. The reads will be\n  // non-overlapping but can be in any order. If the function return Status\n  // is not ok, status of individual requests will be ignored and return\n  // status will be assumed for all read requests. The function return status\n  // is only meant for errors that occur before processing individual read\n  // requests.\n  virtual IOStatus MultiRead(FSReadRequest* reqs, size_t num_reqs,\n                             const IOOptions& options, IODebugContext* dbg) {\n    assert(reqs != nullptr);\n    for (size_t i = 0; i < num_reqs; ++i) {\n      FSReadRequest& req = reqs[i];\n      req.status =\n          Read(req.offset, req.len, options, &req.result, req.scratch, dbg);\n    }\n    return IOStatus::OK();\n  }\n\n  // Tries to get an unique ID for this file that will be the same each time\n  // the file is opened (and will stay the same while the file is open).\n  // Furthermore, it tries to make this ID at most \"max_size\" bytes. If such an\n  // ID can be created this function returns the length of the ID and places it\n  // in \"id\"; otherwise, this function returns 0, in which case \"id\"\n  // may not have been modified.\n  //\n  // This function guarantees, for IDs from a given environment, two unique ids\n  // cannot be made equal to each other by adding arbitrary bytes to one of\n  // them. That is, no unique ID is the prefix of another.\n  //\n  // This function guarantees that the returned ID will not be interpretable as\n  // a single varint.\n  //\n  // Note: these IDs are only valid for the duration of the process.\n  virtual size_t GetUniqueId(char* /*id*/, size_t /*max_size*/) const {\n    return 0;  // Default implementation to prevent issues with backwards\n               // compatibility.\n  }\n\n  virtual void Hint(AccessPattern /*pattern*/) {}\n\n  // Indicates the upper layers if the current RandomAccessFile implementation\n  // uses direct IO.\n  virtual bool use_direct_io() const { return false; }\n\n  // Use the returned alignment value to allocate\n  // aligned buffer for Direct I/O\n  virtual size_t GetRequiredBufferAlignment() const { return kDefaultPageSize; }\n\n  // Remove any kind of caching of data from the offset to offset+length\n  // of this file. If the length is 0, then it refers to the end of file.\n  // If the system is not caching the file contents, then this is a noop.\n  virtual IOStatus InvalidateCache(size_t /*offset*/, size_t /*length*/) {\n    return IOStatus::NotSupported(\"InvalidateCache not supported.\");\n  }\n\n  // This API reads the requested data in FSReadRequest asynchronously. This is\n  // a asynchronous call, i.e it should return after submitting the request.\n  //\n  // When the read request is completed, callback function specified in cb\n  // should be called with arguments cb_arg and the result populated in\n  // FSReadRequest with result and status fileds updated by FileSystem.\n  // cb_arg should be used by the callback to track the original request\n  // submitted.\n  //\n  // This API should also populate io_handle which should be used by\n  // underlying FileSystem to store the context in order to distinguish the read\n  // requests at their side and provide the custom deletion function in del_fn.\n  // RocksDB guarantees that the del_fn for io_handle will be called after\n  // receiving the callback. Furthermore, RocksDB guarantees that if it calls\n  // the Poll API for this io_handle, del_fn will be called after the Poll\n  // returns. RocksDB is responsible for managing the lifetime of io_handle.\n  //\n  // req contains the request offset and size passed as input parameter of read\n  // request and result and status fields are output parameter set by underlying\n  // FileSystem. The data should always be read into scratch field.\n  //\n  // How to enable:\n  // In order to enable ReadAsync, FS needs to override SupportedOps() API and\n  // set FSSupportedOps::kAsyncIO in SupportedOps() as:\n  //  {\n  //    supported_ops |= (1 << FSSupportedOps::kAsyncIO);\n  //  }\n  //\n  // Note: If FS supports ReadAsync API, it should also override Poll and\n  // AbortIO API.\n  //\n  // Default implementation is to read the data synchronously.\n  virtual IOStatus ReadAsync(FSReadRequest& req, const IOOptions& opts,\n                             std::function<void(FSReadRequest&, void*)> cb,\n                             void* cb_arg, void** /*io_handle*/,\n                             IOHandleDeleter* /*del_fn*/, IODebugContext* dbg) {\n    req.status =\n        Read(req.offset, req.len, opts, &(req.result), req.scratch, dbg);\n    cb(req, cb_arg);\n    return IOStatus::OK();\n  }\n\n  // EXPERIMENTAL\n  // When available, returns the actual temperature for the file. This is\n  // useful in case some outside process moves a file from one tier to another,\n  // though the temperature is generally expected not to change while a file is\n  // open.\n  virtual Temperature GetTemperature() const { return Temperature::kUnknown; }\n\n  // If you're adding methods here, remember to add them to\n  // RandomAccessFileWrapper too.\n};", "fixed_code": "class FSRandomAccessFile {\n public:\n  FSRandomAccessFile() {}\n\n  virtual ~FSRandomAccessFile() {}\n\n  // Provide static constants for access patterns\n  static constexpr AccessPattern kNormal = AccessPattern::NORMAL;\n  static constexpr AccessPattern kRandom = AccessPattern::RANDOM;\n  static constexpr AccessPattern kSequential = AccessPattern::SEQUENTIAL;\n  static constexpr AccessPattern kWillNeed = AccessPattern::WILLNEED;\n  static constexpr AccessPattern kDontNeed = AccessPattern::DONTNEED;\n\n  // Read up to \"n\" bytes from the file starting at \"offset\".\n  // \"scratch[0..n-1]\" may be written by this routine.  Sets \"*result\"\n  // to the data that was read (including if fewer than \"n\" bytes were\n  // successfully read).  May set \"*result\" to point at data in\n  // \"scratch[0..n-1]\", so \"scratch[0..n-1]\" must be live when\n  // \"*result\" is used.  If an error was encountered, returns a non-OK\n  // status.\n  //\n  // After call, result->size() < n only if end of file has been\n  // reached (or non-OK status). Read might fail if called again after\n  // first result->size() < n.\n  //\n  // Safe for concurrent use by multiple threads.\n  // If Direct I/O enabled, offset, n, and scratch should be aligned properly.\n  virtual IOStatus Read(uint64_t offset, size_t n, const IOOptions& options,\n                        Slice* result, char* scratch,\n                        IODebugContext* dbg) const = 0;\n\n  // Readahead the file starting from offset by n bytes for caching.\n  // If it's not implemented (default: `NotSupported`), RocksDB will create\n  // internal prefetch buffer to improve read performance.\n  virtual IOStatus Prefetch(uint64_t /*offset*/, size_t /*n*/,\n                            const IOOptions& /*options*/,\n                            IODebugContext* /*dbg*/) {\n    return IOStatus::NotSupported(\"Prefetch\");\n  }\n\n  // Read a bunch of blocks as described by reqs. The blocks can\n  // optionally be read in parallel. This is a synchronous call, i.e it\n  // should return after all reads have completed. The reads will be\n  // non-overlapping but can be in any order. If the function return Status\n  // is not ok, status of individual requests will be ignored and return\n  // status will be assumed for all read requests. The function return status\n  // is only meant for errors that occur before processing individual read\n  // requests.\n  virtual IOStatus MultiRead(FSReadRequest* reqs, size_t num_reqs,\n                             const IOOptions& options, IODebugContext* dbg) {\n    assert(reqs != nullptr);\n    for (size_t i = 0; i < num_reqs; ++i) {\n      FSReadRequest& req = reqs[i];\n      req.status =\n          Read(req.offset, req.len, options, &req.result, req.scratch, dbg);\n    }\n    return IOStatus::OK();\n  }\n\n  // Tries to get an unique ID for this file that will be the same each time\n  // the file is opened (and will stay the same while the file is open).\n  // Furthermore, it tries to make this ID at most \"max_size\" bytes. If such an\n  // ID can be created this function returns the length of the ID and places it\n  // in \"id\"; otherwise, this function returns 0, in which case \"id\"\n  // may not have been modified.\n  //\n  // This function guarantees, for IDs from a given environment, two unique ids\n  // cannot be made equal to each other by adding arbitrary bytes to one of\n  // them. That is, no unique ID is the prefix of another.\n  //\n  // This function guarantees that the returned ID will not be interpretable as\n  // a single varint.\n  //\n  // Note: these IDs are only valid for the duration of the process.\n  virtual size_t GetUniqueId(char* /*id*/, size_t /*max_size*/) const {\n    return 0;  // Default implementation to prevent issues with backwards\n               // compatibility.\n  }\n\n  virtual void Hint(AccessPattern /*pattern*/) {}\n\n  // Indicates the upper layers if the current RandomAccessFile implementation\n  // uses direct IO.\n  virtual bool use_direct_io() const { return false; }\n\n  // Use the returned alignment value to allocate\n  // aligned buffer for Direct I/O\n  virtual size_t GetRequiredBufferAlignment() const { return kDefaultPageSize; }\n\n  // Remove any kind of caching of data from the offset to offset+length\n  // of this file. If the length is 0, then it refers to the end of file.\n  // If the system is not caching the file contents, then this is a noop.\n  virtual IOStatus InvalidateCache(size_t /*offset*/, size_t /*length*/) {\n    return IOStatus::NotSupported(\"InvalidateCache not supported.\");\n  }\n\n  // This API reads the requested data in FSReadRequest asynchronously. This is\n  // a asynchronous call, i.e it should return after submitting the request.\n  //\n  // When the read request is completed, callback function specified in cb\n  // should be called with arguments cb_arg and the result populated in\n  // FSReadRequest with result and status fileds updated by FileSystem.\n  // cb_arg should be used by the callback to track the original request\n  // submitted.\n  //\n  // This API should also populate io_handle which should be used by\n  // underlying FileSystem to store the context in order to distinguish the read\n  // requests at their side and provide the custom deletion function in del_fn.\n  // RocksDB guarantees that the del_fn for io_handle will be called after\n  // receiving the callback. Furthermore, RocksDB guarantees that if it calls\n  // the Poll API for this io_handle, del_fn will be called after the Poll\n  // returns. RocksDB is responsible for managing the lifetime of io_handle.\n  //\n  // req contains the request offset and size passed as input parameter of read\n  // request and result and status fields are output parameter set by underlying\n  // FileSystem. The data should always be read into scratch field.\n  //\n  // How to enable:\n  // In order to enable ReadAsync, FS needs to override SupportedOps() API and\n  // set FSSupportedOps::kAsyncIO in SupportedOps() as:\n  //  {\n  //    supported_ops |= (1 << FSSupportedOps::kAsyncIO);\n  //  }\n  //\n  // Note: If FS supports ReadAsync API, it should also override Poll and\n  // AbortIO API.\n  //\n  // Default implementation is to read the data synchronously.\n  virtual IOStatus ReadAsync(FSReadRequest& req, const IOOptions& opts,\n                             std::function<void(FSReadRequest&, void*)> cb,\n                             void* cb_arg, void** /*io_handle*/,\n                             IOHandleDeleter* /*del_fn*/, IODebugContext* dbg) {\n    req.status =\n        Read(req.offset, req.len, opts, &(req.result), req.scratch, dbg);\n    cb(req, cb_arg);\n    return IOStatus::OK();\n  }\n\n  // EXPERIMENTAL\n  // When available, returns the actual temperature for the file. This is\n  // useful in case some outside process moves a file from one tier to another,\n  // though the temperature is generally expected not to change while a file is\n  // open.\n  virtual Temperature GetTemperature() const { return Temperature::kUnknown; }\n\n  // If you're adding methods here, remember to add them to\n  // RandomAccessFileWrapper too.\n};", "confidence": 0.5, "explanation": ""}], "errors_before": ["./include/rocksdb/env.h:851:21: error: 'AccessPattern' has not been declared", "./include/rocksdb/env.h:1745:13: error: 'AccessPattern' has not been declared", "db/blob/blob_file_reader.cc:127:36: error: 'kRandom' is not a member of 'alternative_rocksdb_ns::FSRandomAccessFile'"], "errors_after": ["./include/rocksdb/env.h:851:21: error: 'AccessPattern' has not been declared", "./include/rocksdb/env.h:1745:13: error: 'AccessPattern' has not been declared"], "error_detail": "db/blob/blob_file_reader.cc:127:36: error: 'kRandom' is not a member of 'alternative_rocksdb_ns::FSRandomAccessFile'\n  127 |     file->Hint(FSRandomAccessFile::kRandom);\n      |                                    ^~~~~~~", "time": 61.069695711135864, "evaluation_mode": "full"}, "timestamp": "2025-08-20 20:12:05"}
{"instance_index": 36, "error_index": 4, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "db/blob/blob_file_reader.cc:127:36: error: no member named 'kRandom' in 'rocksdb::FSRandomAccessFile'", "patches": [{"error_line": "db/blob/blob_file_reader.cc:127:36: error: no member named 'kRandom' in 'rocksdb::FSRandomAccessFile'", "file_path": "include/rocksdb/file_system.h", "start_line": 914, "end_line": 1054, "original_code": "class FSRandomAccessFile {\n public:\n  FSRandomAccessFile() {}\n\n  virtual ~FSRandomAccessFile() {}\n\n  // Read up to \"n\" bytes from the file starting at \"offset\".\n  // \"scratch[0..n-1]\" may be written by this routine.  Sets \"*result\"\n  // to the data that was read (including if fewer than \"n\" bytes were\n  // successfully read).  May set \"*result\" to point at data in\n  // \"scratch[0..n-1]\", so \"scratch[0..n-1]\" must be live when\n  // \"*result\" is used.  If an error was encountered, returns a non-OK\n  // status.\n  //\n  // After call, result->size() < n only if end of file has been\n  // reached (or non-OK status). Read might fail if called again after\n  // first result->size() < n.\n  //\n  // Safe for concurrent use by multiple threads.\n  // If Direct I/O enabled, offset, n, and scratch should be aligned properly.\n  virtual IOStatus Read(uint64_t offset, size_t n, const IOOptions& options,\n                        Slice* result, char* scratch,\n                        IODebugContext* dbg) const = 0;\n\n  // Readahead the file starting from offset by n bytes for caching.\n  // If it's not implemented (default: `NotSupported`), RocksDB will create\n  // internal prefetch buffer to improve read performance.\n  virtual IOStatus Prefetch(uint64_t /*offset*/, size_t /*n*/,\n                            const IOOptions& /*options*/,\n                            IODebugContext* /*dbg*/) {\n    return IOStatus::NotSupported(\"Prefetch\");\n  }\n\n  // Read a bunch of blocks as described by reqs. The blocks can\n  // optionally be read in parallel. This is a synchronous call, i.e it\n  // should return after all reads have completed. The reads will be\n  // non-overlapping but can be in any order. If the function return Status\n  // is not ok, status of individual requests will be ignored and return\n  // status will be assumed for all read requests. The function return status\n  // is only meant for errors that occur before processing individual read\n  // requests.\n  virtual IOStatus MultiRead(FSReadRequest* reqs, size_t num_reqs,\n                             const IOOptions& options, IODebugContext* dbg) {\n    assert(reqs != nullptr);\n    for (size_t i = 0; i < num_reqs; ++i) {\n      FSReadRequest& req = reqs[i];\n      req.status =\n          Read(req.offset, req.len, options, &req.result, req.scratch, dbg);\n    }\n    return IOStatus::OK();\n  }\n\n  // Tries to get an unique ID for this file that will be the same each time\n  // the file is opened (and will stay the same while the file is open).\n  // Furthermore, it tries to make this ID at most \"max_size\" bytes. If such an\n  // ID can be created this function returns the length of the ID and places it\n  // in \"id\"; otherwise, this function returns 0, in which case \"id\"\n  // may not have been modified.\n  //\n  // This function guarantees, for IDs from a given environment, two unique ids\n  // cannot be made equal to each other by adding arbitrary bytes to one of\n  // them. That is, no unique ID is the prefix of another.\n  //\n  // This function guarantees that the returned ID will not be interpretable as\n  // a single varint.\n  //\n  // Note: these IDs are only valid for the duration of the process.\n  virtual size_t GetUniqueId(char* /*id*/, size_t /*max_size*/) const {\n    return 0;  // Default implementation to prevent issues with backwards\n               // compatibility.\n  }\n\n  virtual void Hint(AccessPattern /*pattern*/) {}\n\n  // Indicates the upper layers if the current RandomAccessFile implementation\n  // uses direct IO.\n  virtual bool use_direct_io() const { return false; }\n\n  // Use the returned alignment value to allocate\n  // aligned buffer for Direct I/O\n  virtual size_t GetRequiredBufferAlignment() const { return kDefaultPageSize; }\n\n  // Remove any kind of caching of data from the offset to offset+length\n  // of this file. If the length is 0, then it refers to the end of file.\n  // If the system is not caching the file contents, then this is a noop.\n  virtual IOStatus InvalidateCache(size_t /*offset*/, size_t /*length*/) {\n    return IOStatus::NotSupported(\"InvalidateCache not supported.\");\n  }\n\n  // This API reads the requested data in FSReadRequest asynchronously. This is\n  // a asynchronous call, i.e it should return after submitting the request.\n  //\n  // When the read request is completed, callback function specified in cb\n  // should be called with arguments cb_arg and the result populated in\n  // FSReadRequest with result and status fileds updated by FileSystem.\n  // cb_arg should be used by the callback to track the original request\n  // submitted.\n  //\n  // This API should also populate io_handle which should be used by\n  // underlying FileSystem to store the context in order to distinguish the read\n  // requests at their side and provide the custom deletion function in del_fn.\n  // RocksDB guarantees that the del_fn for io_handle will be called after\n  // receiving the callback. Furthermore, RocksDB guarantees that if it calls\n  // the Poll API for this io_handle, del_fn will be called after the Poll\n  // returns. RocksDB is responsible for managing the lifetime of io_handle.\n  //\n  // req contains the request offset and size passed as input parameter of read\n  // request and result and status fields are output parameter set by underlying\n  // FileSystem. The data should always be read into scratch field.\n  //\n  // How to enable:\n  // In order to enable ReadAsync, FS needs to override SupportedOps() API and\n  // set FSSupportedOps::kAsyncIO in SupportedOps() as:\n  //  {\n  //    supported_ops |= (1 << FSSupportedOps::kAsyncIO);\n  //  }\n  //\n  // Note: If FS supports ReadAsync API, it should also override Poll and\n  // AbortIO API.\n  //\n  // Default implementation is to read the data synchronously.\n  virtual IOStatus ReadAsync(FSReadRequest& req, const IOOptions& opts,\n                             std::function<void(FSReadRequest&, void*)> cb,\n                             void* cb_arg, void** /*io_handle*/,\n                             IOHandleDeleter* /*del_fn*/, IODebugContext* dbg) {\n    req.status =\n        Read(req.offset, req.len, opts, &(req.result), req.scratch, dbg);\n    cb(req, cb_arg);\n    return IOStatus::OK();\n  }\n\n  // EXPERIMENTAL\n  // When available, returns the actual temperature for the file. This is\n  // useful in case some outside process moves a file from one tier to another,\n  // though the temperature is generally expected not to change while a file is\n  // open.\n  virtual Temperature GetTemperature() const { return Temperature::kUnknown; }\n\n  // If you're adding methods here, remember to add them to\n  // RandomAccessFileWrapper too.\n};", "fixed_code": "class FSRandomAccessFile {\n public:\n  // AccessPattern enum for Hint()\n  enum AccessPattern {\n    kNormal = 0,\n    kRandom = 1,\n    kSequential = 2,\n    kWillNeed = 3,\n    kDontNeed = 4\n  };\n\n  FSRandomAccessFile() {}\n\n  virtual ~FSRandomAccessFile() {}\n\n  // Read up to \"n\" bytes from the file starting at \"offset\".\n  // \"scratch[0..n-1]\" may be written by this routine.  Sets \"*result\"\n  // to the data that was read (including if fewer than \"n\" bytes were\n  // successfully read).  May set \"*result\" to point at data in\n  // \"scratch[0..n-1]\", so \"scratch[0..n-1]\" must be live when\n  // \"*result\" is used.  If an error was encountered, returns a non-OK\n  // status.\n  //\n  // After call, result->size() < n only if end of file has been\n  // reached (or non-OK status). Read might fail if called again after\n  // first result->size() < n.\n  //\n  // Safe for concurrent use by multiple threads.\n  // If Direct I/O enabled, offset, n, and scratch should be aligned properly.\n  virtual IOStatus Read(uint64_t offset, size_t n, const IOOptions& options,\n                        Slice* result, char* scratch,\n                        IODebugContext* dbg) const = 0;\n\n  // Readahead the file starting from offset by n bytes for caching.\n  // If it's not implemented (default: `NotSupported`), RocksDB will create\n  // internal prefetch buffer to improve read performance.\n  virtual IOStatus Prefetch(uint64_t /*offset*/, size_t /*n*/,\n                            const IOOptions& /*options*/,\n                            IODebugContext* /*dbg*/) {\n    return IOStatus::NotSupported(\"Prefetch\");\n  }\n\n  // Read a bunch of blocks as described by reqs. The blocks can\n  // optionally be read in parallel. This is a synchronous call, i.e it\n  // should return after all reads have completed. The reads will be\n  // non-overlapping but can be in any order. If the function return Status\n  // is not ok, status of individual requests will be ignored and return\n  // status will be assumed for all read requests. The function return status\n  // is only meant for errors that occur before processing individual read\n  // requests.\n  virtual IOStatus MultiRead(FSReadRequest* reqs, size_t num_reqs,\n                             const IOOptions& options, IODebugContext* dbg) {\n    assert(reqs != nullptr);\n    for (size_t i = 0; i < num_reqs; ++i) {\n      FSReadRequest& req = reqs[i];\n      req.status =\n          Read(req.offset, req.len, options, &req.result, req.scratch, dbg);\n    }\n    return IOStatus::OK();\n  }\n\n  // Tries to get an unique ID for this file that will be the same each time\n  // the file is opened (and will stay the same while the file is open).\n  // Furthermore, it tries to make this ID at most \"max_size\" bytes. If such an\n  // ID can be created this function returns the length of the ID and places it\n  // in \"id\"; otherwise, this function returns 0, in which case \"id\"\n  // may not have been modified.\n  //\n  // This function guarantees, for IDs from a given environment, two unique ids\n  // cannot be made equal to each other by adding arbitrary bytes to one of\n  // them. That is, no unique ID is the prefix of another.\n  //\n  // This function guarantees that the returned ID will not be interpretable as\n  // a single varint.\n  //\n  // Note: these IDs are only valid for the duration of the process.\n  virtual size_t GetUniqueId(char* /*id*/, size_t /*max_size*/) const {\n    return 0;  // Default implementation to prevent issues with backwards\n               // compatibility.\n  }\n\n  virtual void Hint(AccessPattern /*pattern*/) {}\n\n  // Indicates the upper layers if the current RandomAccessFile implementation\n  // uses direct IO.\n  virtual bool use_direct_io() const { return false; }\n\n  // Use the returned alignment value to allocate\n  // aligned buffer for Direct I/O\n  virtual size_t GetRequiredBufferAlignment() const { return kDefaultPageSize; }\n\n  // Remove any kind of caching of data from the offset to offset+length\n  // of this file. If the length is 0, then it refers to the end of file.\n  // If the system is not caching the file contents, then this is a noop.\n  virtual IOStatus InvalidateCache(size_t /*offset*/, size_t /*length*/) {\n    return IOStatus::NotSupported(\"InvalidateCache not supported.\");\n  }\n\n  // This API reads the requested data in FSReadRequest asynchronously. This is\n  // a asynchronous call, i.e it should return after submitting the request.\n  //\n  // When the read request is completed, callback function specified in cb\n  // should be called with arguments cb_arg and the result populated in\n  // FSReadRequest with result and status fileds updated by FileSystem.\n  // cb_arg should be used by the callback to track the original request\n  // submitted.\n  //\n  // This API should also populate io_handle which should be used by\n  // underlying FileSystem to store the context in order to distinguish the read\n  // requests at their side and provide the custom deletion function in del_fn.\n  // RocksDB guarantees that the del_fn for io_handle will be called after\n  // receiving the callback. Furthermore, RocksDB guarantees that if it calls\n  // the Poll API for this io_handle, del_fn will be called after the Poll\n  // returns. RocksDB is responsible for managing the lifetime of io_handle.\n  //\n  // req contains the request offset and size passed as input parameter of read\n  // request and result and status fields are output parameter set by underlying\n  // FileSystem. The data should always be read into scratch field.\n  //\n  // How to enable:\n  // In order to enable ReadAsync, FS needs to override SupportedOps() API and\n  // set FSSupportedOps::kAsyncIO in SupportedOps() as:\n  //  {\n  //    supported_ops |= (1 << FSSupportedOps::kAsyncIO);\n  //  }\n  //\n  // Note: If FS supports ReadAsync API, it should also override Poll and\n  // AbortIO API.\n  //\n  // Default implementation is to read the data synchronously.\n  virtual IOStatus ReadAsync(FSReadRequest& req, const IOOptions& opts,\n                             std::function<void(FSReadRequest&, void*)> cb,\n                             void* cb_arg, void** /*io_handle*/,\n                             IOHandleDeleter* /*del_fn*/, IODebugContext* dbg) {\n    req.status =\n        Read(req.offset, req.len, opts, &(req.result), req.scratch, dbg);\n    cb(req, cb_arg);\n    return IOStatus::OK();\n  }\n\n  // EXPERIMENTAL\n  // When available, returns the actual temperature for the file. This is\n  // useful in case some outside process moves a file from one tier to another,\n  // though the temperature is generally expected not to change while a file is\n  // open.\n  virtual Temperature GetTemperature() const { return Temperature::kUnknown; }\n\n  // If you're adding methods here, remember to add them to\n  // RandomAccessFileWrapper too.\n};", "confidence": 0.5, "explanation": ""}], "errors_before": ["./include/rocksdb/env.h:851:21: error: unknown type name 'AccessPattern'; did you mean 'Env::AccessPattern'?", "./include/rocksdb/env.h:1745:13: error: unknown type name 'AccessPattern'; did you mean 'Env::AccessPattern'?", "./include/rocksdb/env.h./include/rocksdb/env.h:1745:13: error: unknown type name 'AccessPattern'; did you mean 'Env::AccessPattern'?", "virtual void Hint(AccessPattern /*pattern*/) {}./include/rocksdb/env.h:1745:13: error: unknown type name 'AccessPattern'; did you mean 'Env::AccessPattern'?", "db/blob/blob_file_reader.cc:127:36: error: no member named 'kRandom' in 'rocksdb::FSRandomAccessFile'"], "errors_after": ["./include/rocksdb/env.h:851:21: error: unknown type name 'AccessPattern'; did you mean 'Env::AccessPattern'?", "./include/rocksdb/env.h:1745:13: error: unknown type name 'AccessPattern'; did you mean 'Env::AccessPattern'?", "./include/rocksdb/env.h./include/rocksdb/env.h:1745:13: error: unknown type name 'AccessPattern'; did you mean 'Env::AccessPattern'?"], "error_detail": "db/blob/blob_file_reader.cc:127:36: error: no member named 'kRandom' in 'rocksdb::FSRandomAccessFile'\n    file->Hint(FSRandomAccessFile::kRandom);\n               ~~~~~~~~~~~~~~~~~~~~^", "time": 66.88952660560608, "evaluation_mode": "full"}, "timestamp": "2025-08-20 20:12:40"}
{"instance_index": 22, "error_index": 6, "error_result": {"is_successful": false, "is_exact_match": false, "is_valid": false, "error_line": "table/block_based/user_defined_index_wrapper.h:223:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "patches": [{"error_line": "table/block_based/user_defined_index_wrapper.h:223:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "file_path": "./include/rocksdb/user_defined_index.h", "start_line": 93, "end_line": 93, "original_code": "  virtual void Prepare(const ScanOptions scan_opts[], size_t num_opts) = 0;", "fixed_code": "  virtual void Prepare(const ROCKSDB_NAMESPACE::ScanOptions scan_opts[], size_t num_opts) = 0;", "confidence": 0.5, "explanation": ""}], "errors_before": ["include/rocksdb/user_defined_index.h:93:30: error: 'ScanOptions' does not name a type; did you mean 'DBOptions'?", "include/rocksdb/user_defined_index.h:123:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?", "./include/rocksdb/user_defined_index.h:93:30: error: 'ScanOptions' does not name a type; did you mean 'DBOptions'?", "./include/rocksdb/user_defined_index.h:123:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?", "table/block_based/user_defined_index_wrapper.h:182:39: error: cannot convert 'const rocksdb::ScanOptions*' to 'const int*'", "table/block_based/user_defined_index_wrapper.h:223:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "rocksdb/user_defined_index.h:93:30: error: 'ScanOptions' does not name a type; did you mean 'DBOptions'?", "rocksdb/user_defined_index.h:123:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?"], "errors_after": ["include/rocksdb/user_defined_index.h:93:49: error: 'ScanOptions' in namespace 'rocksdb' does not name a type; did you mean 'DBOptions'?", "include/rocksdb/user_defined_index.h:123:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?", "./include/rocksdb/user_defined_index.h:93:49: error: 'ScanOptions' in namespace 'rocksdb' does not name a type; did you mean 'DBOptions'?", "./include/rocksdb/user_defined_index.h:123:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?", "table/block_based/user_defined_index_wrapper.h:182:39: error: cannot convert 'const rocksdb::ScanOptions*' to 'const int*'", "table/block_based/user_defined_index_wrapper.h:223:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "rocksdb/user_defined_index.h:93:49: error: 'ScanOptions' in namespace 'rocksdb' does not name a type; did you mean 'DBOptions'?", "rocksdb/user_defined_index.h:123:13: error: 'ReadOptions' does not name a type; did you mean 'DBOptions'?"], "error_detail": "./include/rocksdb/user_defined_index.h:93:42: note: initializing argument 1 of 'virtual void rocksdb::UserDefinedIndexIterator::Prepare(const int*, size_t)'\ntable/block_based/user_defined_index_wrapper.h:223:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'\n  223 |         udi_reader_->NewIterator(read_options);\n      |                                  ^~~~~~~~~~~~\n      |                                  |\n      |                                  const rocksdb::ReadOptions", "time": 9.707740545272827, "evaluation_mode": "full"}, "timestamp": "2025-08-20 20:26:32"}
{"instance_index": 23, "error_index": 7, "error_result": {"is_successful": false, "is_exact_match": false, "is_valid": false, "error_line": "table/block_based/user_defined_index_wrapper.h:182:39: error: cannot convert 'const rocksdb::ScanOptions*' to 'const int*'", "patches": [{"error_line": "table/block_based/user_defined_index_wrapper.h:182:39: error: cannot convert 'const rocksdb::ScanOptions*' to 'const int*'", "file_path": "table/block_based/user_defined_index_wrapper.h", "start_line": 181, "end_line": 183, "original_code": "  void Prepare(const std::vector<ScanOptions>* scan_opts) override {\n    udi_iter_->Prepare(scan_opts->data(), scan_opts->size());\n  }", "fixed_code": "  void Prepare(const std::vector<ScanOptions>* scan_opts) override {\n    udi_iter_->Prepare(scan_opts->data(), static_cast<size_t>(scan_opts->size()));\n  }", "confidence": 0.5, "explanation": ""}], "errors_before": ["include/rocksdb/user_defined_index.h:88:30: error: 'ScanOptions' does not name a type", "include/rocksdb/user_defined_index.h:118:13: error: 'ReadOptions' does not name a type", "include/rocksdb/user_defined_index.h:126:53: error: expected class-name before '{' token", "./include/rocksdb/user_defined_index.h:88:30: error: 'ScanOptions' does not name a type", "./include/rocksdb/user_defined_index.h:118:13: error: 'ReadOptions' does not name a type", "./include/rocksdb/user_defined_index.h:126:53: error: expected class-name before '{' token", "table/block_based/user_defined_index_wrapper.h:182:39: error: cannot convert 'const rocksdb::ScanOptions*' to 'const int*'", "table/block_based/user_defined_index_wrapper.h:223:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "rocksdb/user_defined_index.h:88:30: error: 'ScanOptions' does not name a type", "rocksdb/user_defined_index.h:118:13: error: 'ReadOptions' does not name a type", "rocksdb/user_defined_index.h:126:53: error: expected class-name before '{' token"], "errors_after": ["include/rocksdb/user_defined_index.h:88:30: error: 'ScanOptions' does not name a type", "include/rocksdb/user_defined_index.h:118:13: error: 'ReadOptions' does not name a type", "include/rocksdb/user_defined_index.h:126:53: error: expected class-name before '{' token", "./include/rocksdb/user_defined_index.h:88:30: error: 'ScanOptions' does not name a type", "./include/rocksdb/user_defined_index.h:118:13: error: 'ReadOptions' does not name a type", "./include/rocksdb/user_defined_index.h:126:53: error: expected class-name before '{' token", "table/block_based/user_defined_index_wrapper.h:182:39: error: cannot convert 'const rocksdb::ScanOptions*' to 'const int*'", "table/block_based/user_defined_index_wrapper.h:223:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "rocksdb/user_defined_index.h:88:30: error: 'ScanOptions' does not name a type", "rocksdb/user_defined_index.h:118:13: error: 'ReadOptions' does not name a type", "rocksdb/user_defined_index.h:126:53: error: expected class-name before '{' token"], "error_detail": "table/block_based/user_defined_index_wrapper.h:182:39: error: cannot convert 'const rocksdb::ScanOptions*' to 'const int*'\n  182 |     udi_iter_->Prepare(scan_opts->data(), scan_opts->size());\n      |                        ~~~~~~~~~~~~~~~^~\n      |                                       |\n      |                                       const rocksdb::ScanOptions*", "time": 10.417057275772095, "evaluation_mode": "full"}, "timestamp": "2025-08-20 20:36:27"}
{"instance_index": 23, "error_index": 8, "error_result": {"is_successful": false, "is_exact_match": false, "is_valid": false, "error_line": "table/block_based/user_defined_index_wrapper.h:223:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "patches": [{"error_line": "table/block_based/user_defined_index_wrapper.h:223:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "file_path": "table/block_based/user_defined_index_wrapper.h", "start_line": 223, "end_line": 223, "original_code": "        udi_reader_->NewIterator(read_options);", "fixed_code": "        std::unique_ptr<UserDefinedIndexIterator> udi_iter =\n            udi_reader_->NewIterator(read_options);", "confidence": 0.5, "explanation": ""}], "errors_before": ["include/rocksdb/user_defined_index.h:88:30: error: 'ScanOptions' does not name a type", "include/rocksdb/user_defined_index.h:118:13: error: 'ReadOptions' does not name a type", "include/rocksdb/user_defined_index.h:126:53: error: expected class-name before '{' token", "./include/rocksdb/user_defined_index.h:88:30: error: 'ScanOptions' does not name a type", "./include/rocksdb/user_defined_index.h:118:13: error: 'ReadOptions' does not name a type", "./include/rocksdb/user_defined_index.h:126:53: error: expected class-name before '{' token", "table/block_based/user_defined_index_wrapper.h:182:39: error: cannot convert 'const rocksdb::ScanOptions*' to 'const int*'", "table/block_based/user_defined_index_wrapper.h:223:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'", "rocksdb/user_defined_index.h:88:30: error: 'ScanOptions' does not name a type", "rocksdb/user_defined_index.h:118:13: error: 'ReadOptions' does not name a type", "rocksdb/user_defined_index.h:126:53: error: expected class-name before '{' token"], "errors_after": ["./table/block_based/user_defined_index_wrapper.h:223:51: error: expected primary-expression before 'udi_iter'"], "error_detail": "./include/rocksdb/user_defined_index.h:88:42: note: initializing argument 1 of 'virtual void rocksdb::UserDefinedIndexIterator::Prepare(const int*, size_t)'\ntable/block_based/user_defined_index_wrapper.h:223:34: error: cannot convert 'const rocksdb::ReadOptions' to 'const int&'\n  223 |         udi_reader_->NewIterator(read_options);\n      |                                  ^~~~~~~~~~~~\n      |                                  |\n      |                                  const rocksdb::ReadOptions", "time": 10.208770275115967, "evaluation_mode": "full"}, "timestamp": "2025-08-20 20:40:28"}
{"instance_index": 41, "error_index": 1, "error_result": {"is_successful": false, "is_exact_match": false, "is_valid": false, "error_line": "tools/db_bench_tool.cc:2857:5: error: use of undeclared identifier 'PrintEnvironment'", "patches": [{"error_line": "tools/db_bench_tool.cc:2857:5: error: use of undeclared identifier 'PrintEnvironment'", "file_path": "tools/db_bench_tool.cc", "start_line": 2856, "end_line": 2858, "original_code": "    void PrintHeader(const Options& options) {\n        PrintEnvironment();\n        fprintf(stdout,", "fixed_code": "    void PrintHeader(const Options& options) {\n        PrintEnvironment();\n        fprintf(stdout,", "confidence": 0.5, "explanation": ""}, {"error_line": "tools/db_bench_tool.cc:2857:5: error: use of undeclared identifier 'PrintEnvironment'", "file_path": "tools/db_bench_tool.cc", "start_line": 2978, "end_line": 3056, "original_code": "        void PrintEnvironment() {\n            fprintf(stderr, \"RocksDB:    version %s\\n\",\n                    GetRocksVersionAsString(true).c_str());\n\n#if defined(__linux) || defined(__APPLE__) || defined(__FreeBSD__)\n            time_t now = time(nullptr);\n            char buf[52];\n            // Lint complains about ctime() usage, so replace it with ctime_r(). The\n            // requirement is to provide a buffer which is at least 26 bytes.\n            fprintf(stderr, \"Date:       %s\",\n                    ctime_r(&now, buf));  // ctime_r() adds newline\n\n#if defined(__linux)\n            FILE* cpuinfo = fopen(\"/proc/cpuinfo\", \"r\");\n            if (cpuinfo != nullptr) {\n                char line[1000];\n                int num_cpus = 0;\n                std::string cpu_type;\n                std::string cache_size;\n                while (fgets(line, sizeof(line), cpuinfo) != nullptr) {\n                    const char* sep = strchr(line, ':');\n                    if (sep == nullptr) {\n                        continue;\n                    }\n                    Slice key = TrimSpace(Slice(line, sep - 1 - line));\n                    Slice val = TrimSpace(Slice(sep + 1));\n                    if (key == \"model name\") {\n                        ++num_cpus;\n                        cpu_type = val.ToString();\n                    } else if (key == \"cache size\") {\n                        cache_size = val.ToString();\n                    }\n                }\n                fclose(cpuinfo);\n                fprintf(stderr, \"CPU:        %d * %s\\n\", num_cpus, cpu_type.c_str());\n                fprintf(stderr, \"CPUCache:   %s\\n\", cache_size.c_str());\n            }\n#elif defined(__APPLE__)\n            struct host_basic_info h;\n            size_t hlen = HOST_BASIC_INFO_COUNT;\n            if (host_info(mach_host_self(), HOST_BASIC_INFO, (host_info_t)&h,\n                        (uint32_t*)&hlen) == KERN_SUCCESS) {\n                std::string cpu_type;\n                std::string cache_size;\n                size_t hcache_size;\n                hlen = sizeof(hcache_size);\n                if (sysctlbyname(\"hw.cachelinesize\", &hcache_size, &hlen, NULL, 0) ==\n                    0) {\n                    cache_size = std::to_string(hcache_size);\n                }\n                switch (h.cpu_type) {\n                    case CPU_TYPE_X86_64:\n                        cpu_type = \"x86_64\";\n                        break;\n                    case CPU_TYPE_ARM64:\n                        cpu_type = \"arm64\";\n                        break;\n                    default:\n                        break;\n                }\n                fprintf(stderr, \"CPU:        %d * %s\\n\", h.max_cpus, cpu_type.c_str());\n                fprintf(stderr, \"CPUCache:   %s\\n\", cache_size.c_str());\n            }\n#elif defined(__FreeBSD__)\n            int ncpus;\n            size_t len = sizeof(ncpus);\n            int mib[2] = {CTL_HW, HW_NCPU};\n            if (sysctl(mib, 2, &ncpus, &len, nullptr, 0) == 0) {\n                char cpu_type[16];\n                len = sizeof(cpu_type) - 1;\n                mib[1] = HW_MACHINE;\n                if (sysctl(mib, 2, cpu_type, &len, nullptr, 0) == 0) cpu_type[len] = 0;\n\n                fprintf(stderr, \"CPU:        %d * %s\\n\", ncpus, cpu_type);\n                // no programmatic way to get the cache line size except on PPC\n            }\n#endif\n#endif\n        }", "fixed_code": "        void PrintEnvironment() {\n            fprintf(stderr, \"RocksDB:    version %s\\n\",\n                    GetRocksVersionAsString(true).c_str());\n\n#if defined(__linux) || defined(__APPLE__) || defined(__FreeBSD__)\n            time_t now = time(nullptr);\n            char buf[52];\n            // Lint complains about ctime() usage, so replace it with ctime_r(). The\n            // requirement is to provide a buffer which is at least 26 bytes.\n            fprintf(stderr, \"Date:       %s\",\n                    ctime_r(&now, buf));  // ctime_r() adds newline\n\n#if defined(__linux)\n            FILE* cpuinfo = fopen(\"/proc/cpuinfo\", \"r\");\n            if (cpuinfo != nullptr) {\n                char line[1000];\n                int num_cpus = 0;\n                std::string cpu_type;\n                std::string cache_size;\n                while (fgets(line, sizeof(line), cpuinfo) != nullptr) {\n                    const char* sep = strchr(line, ':');\n                    if (sep == nullptr) {\n                        continue;\n                    }\n                    Slice key = TrimSpace(Slice(line, sep - 1 - line));\n                    Slice val = TrimSpace(Slice(sep + 1));\n                    if (key == \"model name\") {\n                        ++num_cpus;\n                        cpu_type = val.ToString();\n                    } else if (key == \"cache size\") {\n                        cache_size = val.ToString();\n                    }\n                }\n                fclose(cpuinfo);\n                fprintf(stderr, \"CPU:        %d * %s\\n\", num_cpus, cpu_type.c_str());\n                fprintf(stderr, \"CPUCache:   %s\\n\", cache_size.c_str());\n            }\n#elif defined(__APPLE__)\n            struct host_basic_info h;\n            size_t hlen = HOST_BASIC_INFO_COUNT;\n            if (host_info(mach_host_self(), HOST_BASIC_INFO, (host_info_t)&h,\n                        (uint32_t*)&hlen) == KERN_SUCCESS) {\n                std::string cpu_type;\n                std::string cache_size;\n                size_t hcache_size;\n                hlen = sizeof(hcache_size);\n                if (sysctlbyname(\"hw.cachelinesize\", &hcache_size, &hlen, NULL, 0) ==\n                    0) {\n                    cache_size = std::to_string(hcache_size);\n                }\n                switch (h.cpu_type) {\n                    case CPU_TYPE_X86_64:\n                        cpu_type = \"x86_64\";\n                        break;\n                    case CPU_TYPE_ARM64:\n                        cpu_type = \"arm64\";\n                        break;\n                    default:\n                        break;\n                }\n                fprintf(stderr, \"CPU:        %d * %s\\n\", h.max_cpus, cpu_type.c_str());\n                fprintf(stderr, \"CPUCache:   %s\\n\", cache_size.c_str());\n            }\n#elif defined(__FreeBSD__)\n            int ncpus;\n            size_t len = sizeof(ncpus);\n            int mib[2] = {CTL_HW, HW_NCPU};\n            if (sysctl(mib, 2, &ncpus, &len, nullptr, 0) == 0) {\n                char cpu_type[16];\n                len = sizeof(cpu_type) - 1;\n                mib[1] = HW_MACHINE;\n                if (sysctl(mib, 2, cpu_type, &len, nullptr, 0) == 0) cpu_type[len] = 0;\n\n                fprintf(stderr, \"CPU:        %d * %s\\n\", ncpus, cpu_type);\n                // no programmatic way to get the cache line size except on PPC\n            }\n#endif\n#endif\n        }", "confidence": 0.5, "explanation": ""}], "errors_before": ["tools/db_bench_tool.cc:2857:5: error: use of undeclared identifier 'PrintEnvironment'", "tools/db_bench_tool.cc:2913:7: error: expected expression", "tools/db_bench_tool.cc:2927:7: error: use of undeclared identifier 'PrintWarnings'", "tools/db_bench_tool.cc:2931:49: error: function definition is not allowed here", "tools/db_bench_tool.cc:2965:37: error: function definition is not allowed here", "tools/db_bench_tool.cc:2978:29: error: function definition is not allowed here", "tools/db_bench_tool.cc:3059:46: error: function definition is not allowed here", "tools/db_bench_tool.cc:3084:16: error: use of undeclared identifier 'KeyExpired'", "tools/db_bench_tool.cc:3103:65: error: function definition is not allowed here", "tools/db_bench_tool.cc:3124:39: error: function definition is not allowed here", "tools/db_bench_tool.cc:3129:62: error: function definition is not allowed here", "tools/db_bench_tool.cc:3262:4: error: expected expression", "tools/db_bench_tool.cc:4001:37: error: function definition is not allowed here", "tools/db_bench_tool.cc:4036:65: error: function definition is not allowed here", "tools/db_bench_tool.cc:4115:5: error: expected expression", "tools/db_bench_tool.cc:5152:54: error: function definition is not allowed here", "tools/db_bench_tool.cc:5157:63: error: function definition is not allowed here", "tools/db_bench_tool.cc:5162:41: error: function definition is not allowed here", "tools/db_bench_tool.cc:5164:44: error: function definition is not allowed here"], "errors_after": ["tools/db_bench_tool.cc:10:2: error: unterminated conditional directive", "tools/db_bench_tool.cc:3055:10: error: expected '}'", "tools/db_bench_tool.cc:2857:9: error: use of undeclared identifier 'PrintEnvironment'", "tools/db_bench_tool.cc:2912:7: error: expected expression", "tools/db_bench_tool.cc:2926:7: error: use of undeclared identifier 'PrintWarnings'", "tools/db_bench_tool.cc:2930:49: error: function definition is not allowed here", "tools/db_bench_tool.cc:2964:37: error: function definition is not allowed here", "tools/db_bench_tool.cc:2977:37: error: function definition is not allowed here", "tools/db_bench_tool.cc:3055:10: error: expected ';' after class"], "error_detail": "tools/db_bench_tool.cc:2857:5: error: use of undeclared identifier 'PrintEnvironment'\n    PrintEnvironment();\n    ^", "time": 35.1631178855896, "evaluation_mode": "full"}, "timestamp": "2025-08-20 20:42:51"}
{"instance_index": 44, "error_index": 1, "error_result": {"is_successful": false, "is_exact_match": false, "is_valid": false, "error_line": "sst_file_writer_fuzzer.cc:94:24: error: no matching constructor for initialization of 'rocksdb::TableReaderOptions'", "patches": [{"error_line": "sst_file_writer_fuzzer.cc:94:24: error: no matching constructor for initialization of 'rocksdb::TableReaderOptions'", "file_path": "sst_file_writer_fuzzer.cc", "start_line": 94, "end_line": 96, "original_code": "    TableReaderOptions t_opt(iopts, /*prefix_extractor=*/nullptr, env_options,\n                             cf_ioptions.internal_comparator,\n                             0 /* block_protection_bytes_per_key */);", "fixed_code": "    TableReaderOptions t_opt(iopts, /*prefix_extractor=*/nullptr, env_options,\n                             cf_ioptions.internal_comparator);", "confidence": 0.5, "explanation": ""}], "errors_before": ["sst_file_writer_fuzzer.cc:94:24: error: no matching constructor for initialization of 'rocksdb::TableReaderOptions'"], "errors_after": ["sst_file_writer_fuzzer.cc:94:24: error: no matching constructor for initialization of 'rocksdb::TableReaderOptions'"], "error_detail": "sst_file_writer_fuzzer.cc:94:24: error: no matching constructor for initialization of 'rocksdb::TableReaderOptions'\n    TableReaderOptions t_opt(iopts, /*prefix_extractor=*/nullptr, env_options,\n                       ^     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", "time": 8.77571988105774, "evaluation_mode": "full"}, "timestamp": "2025-08-20 20:45:39"}
{"instance_index": 45, "error_index": 1, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "./include/rocksdb/data_structure.h:60:19: error: constexpr if condition evaluates to 14, which cannot be narrowed to type 'bool' [-Wc++11-narrowing]", "patches": [{"error_line": "./include/rocksdb/data_structure.h:60:19: error: constexpr if condition evaluates to 14, which cannot be narrowed to type 'bool' [-Wc++11-narrowing]", "file_path": "./include/rocksdb/data_structure.h", "start_line": 60, "end_line": 64, "original_code": "    if constexpr ((kMaxValue + 1) & kPieceMask) {\n      tmp[kPieceCount - 1] = (PieceT{1} << ((kMaxValue + 1) & kPieceMask)) - 1;\n    } else {\n      tmp[kPieceCount - 1] = ~PieceT{0};\n    }", "fixed_code": "    if constexpr (((kMaxValue + 1) & kPieceMask) != 0) {\n      tmp[kPieceCount - 1] = (PieceT{1} << ((kMaxValue + 1) & kPieceMask)) - 1;\n    } else {\n      tmp[kPieceCount - 1] = ~PieceT{0};\n    }", "confidence": 0.5, "explanation": ""}], "errors_before": ["./include/rocksdb/data_structure.h:60:19: error: constexpr if condition evaluates to 14, which cannot be narrowed to type 'bool' [-Wc++11-narrowing]", "./include/rocksdb/data_structure.h:60:19: error: constexpr if condition evaluates to 11, which cannot be narrowed to type 'bool' [-Wc++11-narrowing]"], "errors_after": [], "error_detail": "In file included from db_stress_tool/db_stress_test_base.cc:14:\nIn file included from ./db_stress_tool/db_stress_listener.h:12:\nIn file included from ./db_stress_tool/db_stress_shared_state.h:14:\nIn file included from ./db_stress_tool/expected_state.h:17:\nIn file included from ./file/file_util.h:9:\nIn file included from ./file/filename.h:19:\nIn file included from ./options/db_options.h:11:\nIn file included from ./include/rocksdb/options.h:21:\nIn file included from ./include/rocksdb/advanced_options.h:13:\nIn file included from ./include/rocksdb/cache.h:20:\n./include/rocksdb/data_structure.h:60:19: error: constexpr if condition evaluates to 14, which cannot be narrowed to type 'bool' [-Wc++11-narrowing]\n    if constexpr ((kMaxValue + 1) & kPieceMask) {\n                  ^\ndb_stress_tool/db_stress_test_base.cc:168:56: note: in instantiation of member function 'rocksdb::SmallEnumSet<rocksdb::CacheEntryRole, rocksdb::CacheEntryRole::kMisc>::All' requested here\n      opts.do_not_compress_roles = {CacheEntryRoleSet::All()};\n                                                       ^", "time": 10.968665361404419, "evaluation_mode": "full"}, "timestamp": "2025-08-20 21:27:21"}
{"instance_index": 41, "error_index": 2, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "tools/db_bench_tool.cc:2913:7: error: expected expression", "patches": [{"error_line": "tools/db_bench_tool.cc:2913:7: error: expected expression", "file_path": "tools/db_bench_tool.cc", "start_line": 2905, "end_line": 2917, "original_code": "    if (!strcasecmp(FLAGS_compression_manager.c_str(), \"none\")) {\n      if (!strcasecmp(FLAGS_compression_manager.c_str(), \"none\")) {\n        compression = CompressionTypeToString(FLAGS_compression_type_e);\n      } else {\n        fprintf(stdout, \"Compression manager: %s\\n\",\n                FLAGS_compression_manager.c_str());\n      }\n      else {\n        fprintf(stdout, \"Compression manager: %s\\n\",\n                FLAGS_compression_manager.c_str());\n      }\n      fprintf(stdout, \"Compression: %s\\n\", compression.c_str());\n      fprintf(stdout, \"Compression: %s\\n\", compression.c_str());\n      fprintf(stdout, \"Compression sampling rate: %\" PRId64 \"\\n\",\n              FLAGS_sample_for_compression);", "fixed_code": "    if (!strcasecmp(FLAGS_compression_manager.c_str(), \"none\")) {\n      compression = CompressionTypeToString(FLAGS_compression_type_e);\n    } else {\n      fprintf(stdout, \"Compression manager: %s\\n\",\n              FLAGS_compression_manager.c_str());\n    }\n    fprintf(stdout, \"Compression: %s\\n\", compression.c_str());\n    fprintf(stdout, \"Compression sampling rate: %\" PRId64 \"\\n\",\n            FLAGS_sample_for_compression);", "confidence": 0.5, "explanation": ""}], "errors_before": ["tools/db_bench_tool.cc:2857:5: error: use of undeclared identifier 'PrintEnvironment'", "tools/db_bench_tool.cc:2913:7: error: expected expression", "tools/db_bench_tool.cc:2927:7: error: use of undeclared identifier 'PrintWarnings'", "tools/db_bench_tool.cc:2931:49: error: function definition is not allowed here", "tools/db_bench_tool.cc:2965:37: error: function definition is not allowed here", "tools/db_bench_tool.cc:2978:29: error: function definition is not allowed here", "tools/db_bench_tool.cc:3059:46: error: function definition is not allowed here", "tools/db_bench_tool.cc:3084:16: error: use of undeclared identifier 'KeyExpired'", "tools/db_bench_tool.cc:3103:65: error: function definition is not allowed here", "tools/db_bench_tool.cc:3124:39: error: function definition is not allowed here", "tools/db_bench_tool.cc:3129:62: error: function definition is not allowed here", "tools/db_bench_tool.cc:3262:4: error: expected expression", "tools/db_bench_tool.cc:4001:37: error: function definition is not allowed here", "tools/db_bench_tool.cc:4036:65: error: function definition is not allowed here", "tools/db_bench_tool.cc:4115:5: error: expected expression", "tools/db_bench_tool.cc:5152:54: error: function definition is not allowed here", "tools/db_bench_tool.cc:5157:63: error: function definition is not allowed here", "tools/db_bench_tool.cc:5162:41: error: function definition is not allowed here", "tools/db_bench_tool.cc:5164:44: error: function definition is not allowed here"], "errors_after": [], "error_detail": "tools/db_bench_tool.cc:2913:7: error: expected expression\n      else {\n      ^", "time": 23.33016586303711, "evaluation_mode": "full"}, "timestamp": "2025-08-20 21:40:19"}
{"instance_index": 47, "error_index": 1, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "/__w/rocksdb/rocksdb/util/simple_mixed_compressor.h:58:48: error: 'rocksdb::RelaxedAtomic<long long unsigned int> rocksdb::RoundRobinCompressor::g_hack_mixed_compression' is a static data member; it can only be initialized at its definition", "patches": [{"error_line": "/__w/rocksdb/rocksdb/util/simple_mixed_compressor.h:58:48: error: 'rocksdb::RelaxedAtomic<long long unsigned int> rocksdb::RoundRobinCompressor::g_hack_mixed_compression' is a static data member; it can only be initialized at its definition", "file_path": "/__w/rocksdb/rocksdb/util/simple_mixed_compressor.h", "start_line": 57, "end_line": 57, "original_code": "      : CompressorWrapper(std::move(wrapped)), g_hack_mixed_compression(0) {}", "fixed_code": "      : CompressorWrapper(std::move(wrapped)) {}", "confidence": 0.5, "explanation": ""}], "errors_before": ["/tmp/rocksdb_repo_temp_47_xc__lq5i/util/simple_mixed_compressor.h:58:48: error: 'rocksdb::RelaxedAtomic<long long unsigned int> rocksdb::RoundRobinCompressor::g_hack_mixed_compression' is a static data member; it can only be initialized at its definition"], "errors_after": [], "error_detail": "In file included from /__w/rocksdb/rocksdb/tools/ldb_cmd.cc:47:\n/__w/rocksdb/rocksdb/util/simple_mixed_compressor.h: In constructor 'rocksdb::RoundRobinCompressor::RoundRobinCompressor(std::unique_ptr<rocksdb::Compressor>)':\n/__w/rocksdb/rocksdb/util/simple_mixed_compressor.h:58:48: error: 'rocksdb::RelaxedAtomic<long long unsigned int> rocksdb::RoundRobinCompressor::g_hack_mixed_compression' is a static data member; it can only be initialized at its definition\n   58 |       : CompressorWrapper(std::move(wrapped)), g_hack_mixed_compression(0) {}\n      |                                                ^~~~~~~~~~~~~~~~~~~~~~~~", "time": 11.323760509490967, "evaluation_mode": "full"}, "timestamp": "2025-08-20 21:43:01"}
{"instance_index": 41, "error_index": 3, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "tools/db_bench_tool.cc:2927:7: error: use of undeclared identifier 'PrintWarnings'", "patches": [{"error_line": "tools/db_bench_tool.cc:2927:7: error: use of undeclared identifier 'PrintWarnings'", "file_path": "tools/db_bench_tool.cc", "start_line": 2925, "end_line": 2925, "original_code": "", "fixed_code": "    void PrintWarnings(const char* compression);", "confidence": 0.5, "explanation": ""}, {"error_line": "tools/db_bench_tool.cc:2927:7: error: use of undeclared identifier 'PrintWarnings'", "file_path": "tools/db_bench_tool.cc", "start_line": 2935, "end_line": 2955, "original_code": "      }\n    }\n\n// Current the following isn't equivalent to OS_LINUX.\n#if defined(__linux)\n    static Slice TrimSpace(Slice s) {\n      unsigned int start = 0;\n      while (start < s.size() && isspace(s[start])) {\n        start++;\n      }\n      unsigned int limit = static_cast<unsigned int>(s.size());\n      while (limit > start && isspace(s[limit - 1])) {\n        limit--;\n      }\n      return Slice(s.data() + start, limit - start);\n    }\n#endif", "fixed_code": "      }\n    }\n\n    void PrintWarnings(const char* compression) {\n#if defined(__GNUC__) && !defined(__OPTIMIZE__)\n      fprintf(\n          stdout,\n          \"WARNING: Optimization is disabled: benchmarks unnecessarily slow\\n\");\n#endif\n#ifndef NDEBUG\n      fprintf(\n          stdout,\n          \"WARNING: Assertions are enabled; benchmarks unnecessarily slow\\n\");\n#endif\n      if (FLAGS_compression_type_e != ROCKSDB_NAMESPACE::kNoCompression) {\n        // The test string should not be too small.\n        const int len = FLAGS_block_size;\n        std::string input_str(len, 'y');\n        std::string compressed;\n        CompressionOptions opts;\n        CompressionContext context(FLAGS_compression_type_e, opts);\n        CompressionInfo info(opts, context, CompressionDict::GetEmptyDict(),\n                             FLAGS_compression_type_e);\n        bool result = CompressSlice(info, Slice(input_str), &compressed);\n\n        if (!result) {\n          fprintf(stdout, \"WARNING: %s compression is not enabled\\n\",\n                  compression);\n        } else if (compressed.size() >= input_str.size()) {\n          fprintf(stdout, \"WARNING: %s compression is not effective\\n\",\n                  compression);\n        }\n      }\n    }\n\n// Current the following isn't equivalent to OS_LINUX.\n#if defined(__linux)\n    static Slice TrimSpace(Slice s) {\n      unsigned int start = 0;\n      while (start < s.size() && isspace(s[start])) {\n        start++;\n      }\n      unsigned int limit = static_cast<unsigned int>(s.size());\n      while (limit > start && isspace(s[limit - 1])) {\n        limit--;\n      }\n      return Slice(s.data() + start, limit - start);\n    }\n#endif", "confidence": 0.5, "explanation": ""}], "errors_before": ["tools/db_bench_tool.cc:2857:5: error: use of undeclared identifier 'PrintEnvironment'", "tools/db_bench_tool.cc:2913:7: error: expected expression", "tools/db_bench_tool.cc:2927:7: error: use of undeclared identifier 'PrintWarnings'", "tools/db_bench_tool.cc:2931:49: error: function definition is not allowed here", "tools/db_bench_tool.cc:2965:37: error: function definition is not allowed here", "tools/db_bench_tool.cc:2978:29: error: function definition is not allowed here", "tools/db_bench_tool.cc:3059:46: error: function definition is not allowed here", "tools/db_bench_tool.cc:3084:16: error: use of undeclared identifier 'KeyExpired'", "tools/db_bench_tool.cc:3103:65: error: function definition is not allowed here", "tools/db_bench_tool.cc:3124:39: error: function definition is not allowed here", "tools/db_bench_tool.cc:3129:62: error: function definition is not allowed here", "tools/db_bench_tool.cc:3262:4: error: expected expression", "tools/db_bench_tool.cc:4001:37: error: function definition is not allowed here", "tools/db_bench_tool.cc:4036:65: error: function definition is not allowed here", "tools/db_bench_tool.cc:4115:5: error: expected expression", "tools/db_bench_tool.cc:5152:54: error: function definition is not allowed here", "tools/db_bench_tool.cc:5157:63: error: function definition is not allowed here", "tools/db_bench_tool.cc:5162:41: error: function definition is not allowed here", "tools/db_bench_tool.cc:5164:44: error: function definition is not allowed here"], "errors_after": ["tools/db_bench_tool.cc:2857:5: error: use of undeclared identifier 'PrintEnvironment'", "tools/db_bench_tool.cc:2913:7: error: expected expression", "tools/db_bench_tool.cc:2932:49: error: function definition is not allowed here", "tools/db_bench_tool.cc:2964:49: error: function definition is not allowed here", "tools/db_bench_tool.cc:2998:37: error: function definition is not allowed here", "tools/db_bench_tool.cc:3011:29: error: function definition is not allowed here", "tools/db_bench_tool.cc:3092:46: error: function definition is not allowed here", "tools/db_bench_tool.cc:3117:16: error: use of undeclared identifier 'KeyExpired'", "tools/db_bench_tool.cc:3136:65: error: function definition is not allowed here", "tools/db_bench_tool.cc:3157:39: error: function definition is not allowed here", "tools/db_bench_tool.cc:3162:62: error: function definition is not allowed here", "tools/db_bench_tool.cc:3295:4: error: expected expression", "tools/db_bench_tool.cc:4034:37: error: function definition is not allowed here", "tools/db_bench_tool.cc:4069:65: error: function definition is not allowed here", "tools/db_bench_tool.cc:4148:5: error: expected expression", "tools/db_bench_tool.cc:5185:54: error: function definition is not allowed here", "tools/db_bench_tool.cc:5190:63: error: function definition is not allowed here", "tools/db_bench_tool.cc:5195:41: error: function definition is not allowed here", "tools/db_bench_tool.cc:5197:44: error: function definition is not allowed here"], "error_detail": "tools/db_bench_tool.cc:2927:7: error: use of undeclared identifier 'PrintWarnings'\n      PrintWarnings(compression.c_str());\n      ^", "time": 15.787506103515625, "evaluation_mode": "full"}, "timestamp": "2025-08-20 22:45:06"}
{"instance_index": 41, "error_index": 4, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "tools/db_bench_tool.cc:2931:49: error: function definition is not allowed here", "patches": [{"error_line": "tools/db_bench_tool.cc:2931:49: error: function definition is not allowed here", "file_path": "tools/db_bench_tool.cc", "start_line": 2856, "end_line": 2962, "original_code": "  void PrintHeader(const Options& options) {\n    PrintEnvironment();\n    fprintf(stdout,\n            \"Keys:       %d bytes each (+ %d bytes user-defined timestamp)\\n\",\n            FLAGS_key_size, FLAGS_user_timestamp_size);\n    auto avg_value_size = FLAGS_value_size;\n    if (FLAGS_value_size_distribution_type_e == kFixed) {\n      fprintf(stdout,\n              \"Values:     %d bytes each (%d bytes after compression)\\n\",\n              avg_value_size,\n              static_cast<int>(avg_value_size * FLAGS_compression_ratio + 0.5));\n    } else {\n      avg_value_size = (FLAGS_value_size_min + FLAGS_value_size_max) / 2;\n      fprintf(stdout,\n              \"Values:     %d avg bytes each (%d bytes after compression)\\n\",\n              avg_value_size,\n              static_cast<int>(avg_value_size * FLAGS_compression_ratio + 0.5));\n      fprintf(stdout, \"Values Distribution: %s (min: %d, max: %d)\\n\",\n              FLAGS_value_size_distribution_type.c_str(), FLAGS_value_size_min,\n              FLAGS_value_size_max);\n    }\n    fprintf(stdout, \"Entries:    %\" PRIu64 \"\\n\", num_);\n    fprintf(stdout, \"Prefix:    %d bytes\\n\", FLAGS_prefix_size);\n    fprintf(stdout, \"Keys per prefix:    %\" PRIu64 \"\\n\", keys_per_prefix_);\n    fprintf(stdout, \"RawSize:    %.1f MB (estimated)\\n\",\n            ((static_cast<int64_t>(FLAGS_key_size + avg_value_size) * num_) /\n             1048576.0));\n    fprintf(\n        stdout, \"FileSize:   %.1f MB (estimated)\\n\",\n        (((FLAGS_key_size + avg_value_size * FLAGS_compression_ratio) * num_) /\n         1048576.0));\n    fprintf(stdout, \"Write rate: %\" PRIu64 \" bytes/second\\n\",\n            FLAGS_benchmark_write_rate_limit);\n    fprintf(stdout, \"Read rate: %\" PRIu64 \" ops/second\\n\",\n            FLAGS_benchmark_read_rate_limit);\n    if (FLAGS_enable_numa) {\n      fprintf(stderr, \"Running in NUMA enabled mode.\\n\");\n#ifndef NUMA\n      fprintf(stderr, \"NUMA is not defined in the system.\\n\");\n      exit(1);\n#else\n      if (numa_available() == -1) {\n        fprintf(stderr, \"NUMA is not supported by the system.\\n\");\n        exit(1);\n      }\n#endif\n    }\n    // mixed compression  manager expect compression type to be expliciltiy\n    // configured through Options to be zstd\n    auto compression = std::string(\"zstd\");\n    if (!strcasecmp(FLAGS_compression_manager.c_str(), \"none\")) {\n      if (!strcasecmp(FLAGS_compression_manager.c_str(), \"none\")) {\n        compression = CompressionTypeToString(FLAGS_compression_type_e);\n      } else {\n        fprintf(stdout, \"Compression manager: %s\\n\",\n                FLAGS_compression_manager.c_str());\n      }\n      else {\n        fprintf(stdout, \"Compression manager: %s\\n\",\n                FLAGS_compression_manager.c_str());\n      }\n      fprintf(stdout, \"Compression: %s\\n\", compression.c_str());\n      fprintf(stdout, \"Compression: %s\\n\", compression.c_str());\n      fprintf(stdout, \"Compression sampling rate: %\" PRId64 \"\\n\",\n              FLAGS_sample_for_compression);\n      if (options.memtable_factory != nullptr) {\n        fprintf(stdout, \"Memtablerep: %s\\n\",\n                options.memtable_factory->GetId().c_str());\n      }\n      fprintf(stdout, \"Perf Level: %d\\n\", FLAGS_perf_level);\n\n      PrintWarnings(compression.c_str());\n      fprintf(stdout, \"------------------------------------------------\\n\");\n    }\n\n    void PrintWarnings(const char* compression) {\n#if defined(__GNUC__) && !defined(__OPTIMIZE__)\n      fprintf(\n          stdout,\n          \"WARNING: Optimization is disabled: benchmarks unnecessarily slow\\n\");\n#endif\n#ifndef NDEBUG\n      fprintf(\n          stdout,\n          \"WARNING: Assertions are enabled; benchmarks unnecessarily slow\\n\");\n#endif\n      if (FLAGS_compression_type_e != ROCKSDB_NAMESPACE::kNoCompression) {\n        // The test string should not be too small.\n        const int len = FLAGS_block_size;\n        std::string input_str(len, 'y');\n        std::string compressed;\n        CompressionOptions opts;\n        CompressionContext context(FLAGS_compression_type_e, opts);\n        CompressionInfo info(opts, context, CompressionDict::GetEmptyDict(),\n                             FLAGS_compression_type_e);\n        bool result = CompressSlice(info, Slice(input_str), &compressed);\n\n        if (!result) {\n          fprintf(stdout, \"WARNING: %s compression is not enabled\\n\",\n                  compression);\n        } else if (compressed.size() >= input_str.size()) {\n          fprintf(stdout, \"WARNING: %s compression is not effective\\n\",\n                  compression);\n        }\n      }\n    }", "fixed_code": "  void PrintHeader(const Options& options) {\n    PrintEnvironment();\n    fprintf(stdout,\n            \"Keys:       %d bytes each (+ %d bytes user-defined timestamp)\\n\",\n            FLAGS_key_size, FLAGS_user_timestamp_size);\n    auto avg_value_size = FLAGS_value_size;\n    if (FLAGS_value_size_distribution_type_e == kFixed) {\n      fprintf(stdout,\n              \"Values:     %d bytes each (%d bytes after compression)\\n\",\n              avg_value_size,\n              static_cast<int>(avg_value_size * FLAGS_compression_ratio + 0.5));\n    } else {\n      avg_value_size = (FLAGS_value_size_min + FLAGS_value_size_max) / 2;\n      fprintf(stdout,\n              \"Values:     %d avg bytes each (%d bytes after compression)\\n\",\n              avg_value_size,\n              static_cast<int>(avg_value_size * FLAGS_compression_ratio + 0.5));\n      fprintf(stdout, \"Values Distribution: %s (min: %d, max: %d)\\n\",\n              FLAGS_value_size_distribution_type.c_str(), FLAGS_value_size_min,\n              FLAGS_value_size_max);\n    }\n    fprintf(stdout, \"Entries:    %\" PRIu64 \"\\n\", num_);\n    fprintf(stdout, \"Prefix:    %d bytes\\n\", FLAGS_prefix_size);\n    fprintf(stdout, \"Keys per prefix:    %\" PRIu64 \"\\n\", keys_per_prefix_);\n    fprintf(stdout, \"RawSize:    %.1f MB (estimated)\\n\",\n            ((static_cast<int64_t>(FLAGS_key_size + avg_value_size) * num_) /\n             1048576.0));\n    fprintf(\n        stdout, \"FileSize:   %.1f MB (estimated)\\n\",\n        (((FLAGS_key_size + avg_value_size * FLAGS_compression_ratio) * num_) /\n         1048576.0));\n    fprintf(stdout, \"Write rate: %\" PRIu64 \" bytes/second\\n\",\n            FLAGS_benchmark_write_rate_limit);\n    fprintf(stdout, \"Read rate: %\" PRIu64 \" ops/second\\n\",\n            FLAGS_benchmark_read_rate_limit);\n    if (FLAGS_enable_numa) {\n      fprintf(stderr, \"Running in NUMA enabled mode.\\n\");\n#ifndef NUMA\n      fprintf(stderr, \"NUMA is not defined in the system.\\n\");\n      exit(1);\n#else\n      if (numa_available() == -1) {\n        fprintf(stderr, \"NUMA is not supported by the system.\\n\");\n        exit(1);\n      }\n#endif\n    }\n    // mixed compression  manager expect compression type to be expliciltiy\n    // configured through Options to be zstd\n    auto compression = std::string(\"zstd\");\n    if (!strcasecmp(FLAGS_compression_manager.c_str(), \"none\")) {\n      if (!strcasecmp(FLAGS_compression_manager.c_str(), \"none\")) {\n        compression = CompressionTypeToString(FLAGS_compression_type_e);\n      } else {\n        fprintf(stdout, \"Compression manager: %s\\n\",\n                FLAGS_compression_manager.c_str());\n      }\n      else {\n        fprintf(stdout, \"Compression manager: %s\\n\",\n                FLAGS_compression_manager.c_str());\n      }\n      fprintf(stdout, \"Compression: %s\\n\", compression.c_str());\n      fprintf(stdout, \"Compression: %s\\n\", compression.c_str());\n      fprintf(stdout, \"Compression sampling rate: %\" PRId64 \"\\n\",\n              FLAGS_sample_for_compression);\n      if (options.memtable_factory != nullptr) {\n        fprintf(stdout, \"Memtablerep: %s\\n\",\n                options.memtable_factory->GetId().c_str());\n      }\n      fprintf(stdout, \"Perf Level: %d\\n\", FLAGS_perf_level);\n\n      PrintWarnings(compression.c_str());\n      fprintf(stdout, \"------------------------------------------------\\n\");\n    }\n  }\n\n  void PrintWarnings(const char* compression) {\n#if defined(__GNUC__) && !defined(__OPTIMIZE__)\n    fprintf(\n        stdout,\n        \"WARNING: Optimization is disabled: benchmarks unnecessarily slow\\n\");\n#endif\n#ifndef NDEBUG\n    fprintf(\n        stdout,\n        \"WARNING: Assertions are enabled; benchmarks unnecessarily slow\\n\");\n#endif\n    if (FLAGS_compression_type_e != ROCKSDB_NAMESPACE::kNoCompression) {\n      // The test string should not be too small.\n      const int len = FLAGS_block_size;\n      std::string input_str(len, 'y');\n      std::string compressed;\n      CompressionOptions opts;\n      CompressionContext context(FLAGS_compression_type_e, opts);\n      CompressionInfo info(opts, context, CompressionDict::GetEmptyDict(),\n                           FLAGS_compression_type_e);\n      bool result = CompressSlice(info, Slice(input_str), &compressed);\n\n      if (!result) {\n        fprintf(stdout, \"WARNING: %s compression is not enabled\\n\",\n                compression);\n      } else if (compressed.size() >= input_str.size()) {\n        fprintf(stdout, \"WARNING: %s compression is not effective\\n\",\n                compression);\n      }\n    }\n  }", "confidence": 0.5, "explanation": ""}], "errors_before": ["tools/db_bench_tool.cc:2857:5: error: use of undeclared identifier 'PrintEnvironment'", "tools/db_bench_tool.cc:2913:7: error: expected expression", "tools/db_bench_tool.cc:2927:7: error: use of undeclared identifier 'PrintWarnings'", "tools/db_bench_tool.cc:2931:49: error: function definition is not allowed here", "tools/db_bench_tool.cc:2965:37: error: function definition is not allowed here", "tools/db_bench_tool.cc:2978:29: error: function definition is not allowed here", "tools/db_bench_tool.cc:3059:46: error: function definition is not allowed here", "tools/db_bench_tool.cc:3084:16: error: use of undeclared identifier 'KeyExpired'", "tools/db_bench_tool.cc:3103:65: error: function definition is not allowed here", "tools/db_bench_tool.cc:3124:39: error: function definition is not allowed here", "tools/db_bench_tool.cc:3129:62: error: function definition is not allowed here", "tools/db_bench_tool.cc:3262:4: error: expected expression", "tools/db_bench_tool.cc:4001:37: error: function definition is not allowed here", "tools/db_bench_tool.cc:4036:65: error: function definition is not allowed here", "tools/db_bench_tool.cc:4115:5: error: expected expression", "tools/db_bench_tool.cc:5152:54: error: function definition is not allowed here", "tools/db_bench_tool.cc:5157:63: error: function definition is not allowed here", "tools/db_bench_tool.cc:5162:41: error: function definition is not allowed here", "tools/db_bench_tool.cc:5164:44: error: function definition is not allowed here"], "errors_after": ["tools/db_bench_tool.cc:2913:7: error: expected expression"], "error_detail": "tools/db_bench_tool.cc:2931:49: error: function definition is not allowed here\n    void PrintWarnings(const char* compression) {\n                                                ^", "time": 66.81313419342041, "evaluation_mode": "full"}, "timestamp": "2025-08-20 23:13:12"}
{"instance_index": 52, "error_index": 1, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "util/compression.cc:530:5: error: static_assert failed \"ZSTD not built with full digested dict support\"", "patches": [{"error_line": "util/compression.cc:530:5: error: static_assert failed \"ZSTD not built with full digested dict support\"", "file_path": "util/compression.cc", "start_line": 530, "end_line": 531, "original_code": "    static_assert(false, \"ZSTD not built with full digested dict support\");", "fixed_code": "    (void)dict;\n    return Status::NotSupported(\"ZSTD not built with full digested dict support\");", "confidence": 0.5, "explanation": ""}], "errors_before": ["util/compression.cc:530:5: error: static_assert failed 'ZSTD not built with full digested dict support'"], "errors_after": [], "error_detail": "util/compression.cc:530:5: error: static_assert failed \"ZSTD not built with full digested dict support\"\n    static_assert(false, \"ZSTD not built with full digested dict support\");\n    ^             ~~~~~", "time": 18.512600898742676, "evaluation_mode": "full"}, "timestamp": "2025-08-20 23:13:46"}
{"instance_index": 45, "error_index": 2, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "./include/rocksdb/data_structure.h:60:19: error: constexpr if condition evaluates to 11, which cannot be narrowed to type 'bool' [-Wc++11-narrowing]", "patches": [{"error_line": "./include/rocksdb/data_structure.h:60:19: error: constexpr if condition evaluates to 11, which cannot be narrowed to type 'bool' [-Wc++11-narrowing]", "file_path": "./include/rocksdb/data_structure.h", "start_line": 60, "end_line": 64, "original_code": "    if constexpr ((kMaxValue + 1) & kPieceMask) {\n      tmp[kPieceCount - 1] = (PieceT{1} << ((kMaxValue + 1) & kPieceMask)) - 1;\n    } else {\n      tmp[kPieceCount - 1] = ~PieceT{0};\n    }", "fixed_code": "    if constexpr (((kMaxValue + 1) & kPieceMask) != 0) {\n      tmp[kPieceCount - 1] = (PieceT{1} << ((kMaxValue + 1) & kPieceMask)) - 1;\n    } else {\n      tmp[kPieceCount - 1] = ~PieceT{0};\n    }", "confidence": 0.5, "explanation": ""}], "errors_before": ["./include/rocksdb/data_structure.h:60:19: error: constexpr if condition evaluates to 14, which cannot be narrowed to type 'bool' [-Wc++11-narrowing]", "./include/rocksdb/data_structure.h:60:19: error: constexpr if condition evaluates to 11, which cannot be narrowed to type 'bool' [-Wc++11-narrowing]"], "errors_after": [], "error_detail": "In file included from db_stress_tool/db_stress_test_base.cc:14:\nIn file included from ./db_stress_tool/db_stress_listener.h:12:\nIn file included from ./db_stress_tool/db_stress_shared_state.h:14:\nIn file included from ./db_stress_tool/expected_state.h:17:\nIn file included from ./file/file_util.h:9:\nIn file included from ./file/filename.h:19:\nIn file included from ./options/db_options.h:11:\nIn file included from ./include/rocksdb/options.h:21:\nIn file included from ./include/rocksdb/advanced_options.h:13:\nIn file included from ./include/rocksdb/cache.h:20:\n./include/rocksdb/data_structure.h:60:19: error: constexpr if condition evaluates to 11, which cannot be narrowed to type 'bool' [-Wc++11-narrowing]\n    if constexpr ((kMaxValue + 1) & kPieceMask) {\n                  ^\ndb_stress_tool/db_stress_test_base.cc:4314:57: note: in instantiation of member function 'rocksdb::SmallEnumSet<rocksdb::FileType, rocksdb::kBlobFile>::All' requested here\n    options.checksum_handoff_file_types = {FileTypeSet::All()};\n                                                        ^\nmkdir -p tools && clang++  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Wshift-sign-overflow -Wambiguous-reversed-operator -Wimplicit-fallthrough -Wreinterpret-base-class -Wundefined-reinterpret-cast -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -Wshorten-64-to-32 -DHAVE_UINT128_EXTENSION  -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c tools/io_tracer_parser_tool.cc -o tools/io_tracer_parser_tool.o\nmkdir -p tools && clang++  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Wshift-sign-overflow -Wambiguous-reversed-operator -Wimplicit-fallthrough -Wreinterpret-base-class -Wundefined-reinterpret-cast -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -Wshorten-64-to-32 -DHAVE_UINT128_EXTENSION  -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c tools/ldb_cmd.cc -o tools/ldb_cmd.o\nmkdir -p tools && clang++  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Wshift-sign-overflow -Wambiguous-reversed-operator -Wimplicit-fallthrough -Wreinterpret-base-class -Wundefined-reinterpret-cast -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -Wshorten-64-to-32 -DHAVE_UINT128_EXTENSION  -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c tools/ldb_tool.cc -o tools/ldb_tool.o\nmkdir -p tools && clang++  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Wshift-sign-overflow -Wambiguous-reversed-operator -Wimplicit-fallthrough -Wreinterpret-base-class -Wundefined-reinterpret-cast -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -Wshorten-64-to-32 -DHAVE_UINT128_EXTENSION  -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c tools/sst_dump_tool.cc -o tools/sst_dump_tool.o", "time": 12.033930540084839, "evaluation_mode": "full"}, "timestamp": "2025-08-20 23:17:33"}
{"instance_index": 41, "error_index": 8, "error_result": {"is_successful": false, "is_exact_match": false, "is_valid": false, "error_line": "tools/db_bench_tool.cc:3084:16: error: use of undeclared identifier 'KeyExpired'", "patches": [{"error_line": "tools/db_bench_tool.cc:3084:16: error: use of undeclared identifier 'KeyExpired'", "file_path": "tools/db_bench_tool.cc", "start_line": 3059, "end_line": 3075, "original_code": "    static bool KeyExpired(const TimestampEmulator* timestamp_emulator,\n                           const Slice& key) {\n      const char* pos = key.data();\n      pos += 8;\n      uint64_t timestamp = 0;\n      if (port::kLittleEndian) {\n        int bytes_to_fill = 8;\n        for (int i = 0; i < bytes_to_fill; ++i) {\n          timestamp |=\n              (static_cast<uint64_t>(static_cast<unsigned char>(pos[i]))\n               << ((bytes_to_fill - i - 1) << 3));\n        }\n      } else {\n        memcpy(&timestamp, pos, sizeof(timestamp));\n      }\n      return timestamp_emulator->Get() - timestamp > FLAGS_time_range;\n    }", "fixed_code": "    static bool KeyExpired(const TimestampEmulator* timestamp_emulator,\n                           const Slice& key) {\n      const char* pos = key.data();\n      pos += 8;\n      uint64_t timestamp = 0;\n      if (port::kLittleEndian) {\n        int bytes_to_fill = 8;\n        for (int i = 0; i < bytes_to_fill; ++i) {\n          timestamp |=\n              (static_cast<uint64_t>(static_cast<unsigned char>(pos[i]))\n               << ((bytes_to_fill - i - 1) << 3));\n        }\n      } else {\n        memcpy(&timestamp, pos, sizeof(timestamp));\n      }\n      return timestamp_emulator->Get() - timestamp > FLAGS_time_range;\n    }\n", "confidence": 0.5, "explanation": ""}, {"error_line": "tools/db_bench_tool.cc:3084:16: error: use of undeclared identifier 'KeyExpired'", "file_path": "tools/db_bench_tool.cc", "start_line": 3085, "end_line": 3085, "original_code": "        return KeyExpired(timestamp_emulator_.get(), key);", "fixed_code": "        return Benchmark::KeyExpired(timestamp_emulator_.get(), key);", "confidence": 0.5, "explanation": ""}], "errors_before": ["tools/db_bench_tool.cc:2857:5: error: use of undeclared identifier 'PrintEnvironment'", "tools/db_bench_tool.cc:2913:7: error: expected expression", "tools/db_bench_tool.cc:2927:7: error: use of undeclared identifier 'PrintWarnings'", "tools/db_bench_tool.cc:2931:49: error: function definition is not allowed here", "tools/db_bench_tool.cc:2965:37: error: function definition is not allowed here", "tools/db_bench_tool.cc:2978:29: error: function definition is not allowed here", "tools/db_bench_tool.cc:3059:46: error: function definition is not allowed here", "tools/db_bench_tool.cc:3084:16: error: use of undeclared identifier 'KeyExpired'", "tools/db_bench_tool.cc:3103:65: error: function definition is not allowed here", "tools/db_bench_tool.cc:3124:39: error: function definition is not allowed here", "tools/db_bench_tool.cc:3129:62: error: function definition is not allowed here", "tools/db_bench_tool.cc:3262:4: error: expected expression", "tools/db_bench_tool.cc:4001:37: error: function definition is not allowed here", "tools/db_bench_tool.cc:4036:65: error: function definition is not allowed here", "tools/db_bench_tool.cc:4115:5: error: expected expression", "tools/db_bench_tool.cc:5152:54: error: function definition is not allowed here", "tools/db_bench_tool.cc:5157:63: error: function definition is not allowed here", "tools/db_bench_tool.cc:5162:41: error: function definition is not allowed here", "tools/db_bench_tool.cc:5164:44: error: function definition is not allowed here"], "errors_after": ["tools/db_bench_tool.cc:2857:5: error: use of undeclared identifier 'PrintEnvironment'", "tools/db_bench_tool.cc:2913:7: error: expected expression", "tools/db_bench_tool.cc:2927:7: error: use of undeclared identifier 'PrintWarnings'", "tools/db_bench_tool.cc:2931:49: error: function definition is not allowed here", "tools/db_bench_tool.cc:2965:37: error: function definition is not allowed here", "tools/db_bench_tool.cc:2978:29: error: function definition is not allowed here", "tools/db_bench_tool.cc:3059:46: error: function definition is not allowed here", "tools/db_bench_tool.cc:3085:27: error: no member named 'KeyExpired' in 'rocksdb::Benchmark'", "tools/db_bench_tool.cc:3104:65: error: function definition is not allowed here", "tools/db_bench_tool.cc:3125:39: error: function definition is not allowed here", "tools/db_bench_tool.cc:3130:62: error: function definition is not allowed here", "tools/db_bench_tool.cc:3263:4: error: expected expression", "tools/db_bench_tool.cc:4002:37: error: function definition is not allowed here", "tools/db_bench_tool.cc:4037:65: error: function definition is not allowed here", "tools/db_bench_tool.cc:4116:5: error: expected expression", "tools/db_bench_tool.cc:5153:54: error: function definition is not allowed here", "tools/db_bench_tool.cc:5158:63: error: function definition is not allowed here", "tools/db_bench_tool.cc:5163:41: error: function definition is not allowed here", "tools/db_bench_tool.cc:5165:44: error: function definition is not allowed here"], "error_detail": "tools/db_bench_tool.cc:3084:16: error: use of undeclared identifier 'KeyExpired'\n        return KeyExpired(timestamp_emulator_.get(), key);\n               ^", "time": 35.14895415306091, "evaluation_mode": "full"}, "timestamp": "2025-08-20 23:20:50"}
{"instance_index": 48, "error_index": 1, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "./util/simple_mixed_compressor.h:58:48: error: 'alternative_rocksdb_ns::RelaxedAtomic<long unsigned int> alternative_rocksdb_ns::RoundRobinCompressor::g_hack_mixed_compression' is a static data member; it can only be initialized at its definition", "patches": [{"error_line": "./util/simple_mixed_compressor.h:58:48: error: 'alternative_rocksdb_ns::RelaxedAtomic<long unsigned int> alternative_rocksdb_ns::RoundRobinCompressor::g_hack_mixed_compression' is a static data member; it can only be initialized at its definition", "file_path": "./util/simple_mixed_compressor.h", "start_line": 57, "end_line": 58, "original_code": "  explicit RoundRobinCompressor(std::unique_ptr<Compressor> wrapped)\n      : CompressorWrapper(std::move(wrapped)), g_hack_mixed_compression(0) {}", "fixed_code": "  explicit RoundRobinCompressor(std::unique_ptr<Compressor> wrapped)\n      : CompressorWrapper(std::move(wrapped)) {}", "confidence": 0.5, "explanation": ""}], "errors_before": ["./util/simple_mixed_compressor.h:58:48: error: 'alternative_rocksdb_ns::RelaxedAtomic<long unsigned int> alternative_rocksdb_ns::RoundRobinCompressor::g_hack_mixed_compression' is a static data member; it can only be initialized at its definition"], "errors_after": [], "error_detail": "In file included from db_stress_tool/db_stress_test_base.cc:37:\n./util/simple_mixed_compressor.h: In constructor 'alternative_rocksdb_ns::RoundRobinCompressor::RoundRobinCompressor(std::unique_ptr<alternative_rocksdb_ns::Compressor>)':\n./util/simple_mixed_compressor.h:58:48: error: 'alternative_rocksdb_ns::RelaxedAtomic<long unsigned int> alternative_rocksdb_ns::RoundRobinCompressor::g_hack_mixed_compression' is a static data member; it can only be initialized at its definition\n   58 |       : CompressorWrapper(std::move(wrapped)), g_hack_mixed_compression(0) {}\n      |                                                ^~~~~~~~~~~~~~~~~~~~~~~~\nmkdir -p tools && g++  -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -fno-builtin-memcmp -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -march=native  -DHAVE_UINT128_EXTENSION -fno-elide-constructors  -isystem third-party/gtest-1.8.1/fused-src -DTEST_UINT128_COMPAT=1 -DROCKSDB_MODIFY_NPHASH=1 -DROCKSDB_NAMESPACE=alternative_rocksdb_ns -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -DROCKSDB_ASSERT_STATUS_CHECKED -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c tools/io_tracer_parser.cc -o tools/io_tracer_parser.o", "time": 10.955595016479492, "evaluation_mode": "full"}, "timestamp": "2025-08-20 23:34:49"}
{"instance_index": 46, "error_index": 1, "error_result": {"is_successful": true, "is_exact_match": false, "is_valid": false, "error_line": "./util/simple_mixed_compressor.h:58:48: error: 'rocksdb::RelaxedAtomic<long unsigned int> rocksdb::RoundRobinCompressor::g_hack_mixed_compression' is a static data member; it can only be initialized at its definition", "patches": [{"error_line": "./util/simple_mixed_compressor.h:58:48: error: 'rocksdb::RelaxedAtomic<long unsigned int> rocksdb::RoundRobinCompressor::g_hack_mixed_compression' is a static data member; it can only be initialized at its definition", "file_path": "./util/simple_mixed_compressor.h", "start_line": 57, "end_line": 58, "original_code": "      : CompressorWrapper(std::move(wrapped)), g_hack_mixed_compression(0) {}", "fixed_code": "      : CompressorWrapper(std::move(wrapped)) {}", "confidence": 0.5, "explanation": ""}], "errors_before": ["./util/simple_mixed_compressor.h:58:48: error: 'rocksdb::RelaxedAtomic<long unsigned int> rocksdb::RoundRobinCompressor::g_hack_mixed_compression' is a static data member; it can only be initialized at its definition"], "errors_after": [], "error_detail": "In file included from db_stress_tool/db_stress_test_base.cc:37:\n./util/simple_mixed_compressor.h: In constructor 'rocksdb::RoundRobinCompressor::RoundRobinCompressor(std::unique_ptr<rocksdb::Compressor>)':\n./util/simple_mixed_compressor.h:58:48: error: 'rocksdb::RelaxedAtomic<long unsigned int> rocksdb::RoundRobinCompressor::g_hack_mixed_compression' is a static data member; it can only be initialized at its definition\n   58 |       : CompressorWrapper(std::move(wrapped)), g_hack_mixed_compression(0) {}\n      |                                                ^~~~~~~~~~~~~~~~~~~~~~~~\nmkdir -p cache && g++  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -fno-builtin-memcmp -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -march=native  -DHAVE_UINT128_EXTENSION  -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c cache/compressed_secondary_cache_test.cc -o cache/compressed_secondary_cache_test.o\nmkdir -p cache && g++  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -fno-builtin-memcmp -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -march=native  -DHAVE_UINT128_EXTENSION  -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c cache/lru_cache_test.cc -o cache/lru_cache_test.o\nmkdir -p cache && g++  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -fno-builtin-memcmp -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -march=native  -DHAVE_UINT128_EXTENSION  -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c cache/tiered_secondary_cache_test.cc -o cache/tiered_secondary_cache_test.o\nmkdir -p db/blob && g++  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -fno-builtin-memcmp -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -march=native  -DHAVE_UINT128_EXTENSION  -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c db/blob/blob_counting_iterator_test.cc -o db/blob/blob_counting_iterator_test.o\nmkdir -p db/blob && g++  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -fno-builtin-memcmp -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -march=native  -DHAVE_UINT128_EXTENSION  -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c db/blob/blob_file_addition_test.cc -o db/blob/blob_file_addition_test.o\nmkdir -p db/blob && g++  -fPIC -DROCKSDB_DLL -DROCKSDB_USE_RTTI   -g -W -Wextra -Wall -Wsign-compare -Wshadow -Wunused-parameter -Werror -I. -I./include -std=c++17  -faligned-new -DHAVE_ALIGNED_NEW -DROCKSDB_PLATFORM_POSIX -DROCKSDB_LIB_IO_POSIX  -DOS_LINUX -fno-builtin-memcmp -DROCKSDB_FALLOCATE_PRESENT -DSNAPPY -DGFLAGS=1 -DZLIB -DBZIP2 -DLZ4 -DZSTD -DTBB -DROCKSDB_MALLOC_USABLE_SIZE -DROCKSDB_PTHREAD_ADAPTIVE_MUTEX -DROCKSDB_BACKTRACE -DROCKSDB_RANGESYNC_PRESENT -DROCKSDB_SCHED_GETCPU_PRESENT -DROCKSDB_AUXV_GETAUXVAL_PRESENT -march=native  -DHAVE_UINT128_EXTENSION  -isystem third-party/gtest-1.8.1/fused-src -O2 -fno-omit-frame-pointer -momit-leaf-frame-pointer -Woverloaded-virtual -Wnon-virtual-dtor -Wno-missing-field-initializers -Wno-invalid-offsetof -c db/blob/blob_file_builder_test.cc -o db/blob/blob_file_builder_test.o", "time": 12.739490985870361, "evaluation_mode": "full"}, "timestamp": "2025-08-20 23:35:53"}
